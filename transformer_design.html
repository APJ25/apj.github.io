<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Transformer Design Analysis</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
            color: #334155;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }
        .input-group {
            display: flex;
            flex-direction: column;
            margin-bottom: 1rem;
        }
        .input-group label {
            margin-bottom: 0.5rem;
            font-weight: 600;
        }
        .input-group input, .input-group select {
            padding: 0.75rem;
            border: 1px solid #cbd5e1;
            border-radius: 0.5rem;
            font-size: 1rem;
            background-color: #ffffff;
            transition: border-color 0.2s;
        }
        .input-group input:focus, .input-group select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.25);
        }
        .btn {
            padding: 0.75rem 1.5rem;
            background-color: #3b82f6;
            color: white;
            border-radius: 0.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            border: none;
        }
        .btn:hover {
            background-color: #2563eb;
            transform: translateY(-1px);
        }
        .btn:active {
            transform: translateY(0);
        }
        .plot-container {
            background-color: #ffffff;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
            margin-top: 2rem;
            min-height: 400px; /* Ensure plot div has height */
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative; /* For loading indicator */
        }
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10;
            border-radius: 0.75rem;
        }
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #3b82f6;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 2rem;
            background-color: #ffffff;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            overflow: hidden; /* For rounded corners on table */
        }
        th, td {
            padding: 1rem;
            text-align: left;
            border-bottom: 1px solid #e2e8f0;
        }
        th {
            background-color: #f8fafc;
            font-weight: 600;
            color: #475569;
        }
        tr:last-child td {
            border-bottom: none;
        }
        tr:hover {
            background-color: #f0f4f8;
        }
    </style>
</head>
<body class="p-4">
    <div class="container bg-white rounded-xl shadow-lg p-6 md:p-8">
        <h1 class="text-3xl font-bold text-center text-gray-800 mb-6">Transformer Design Analysis</h1>

        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 mb-8">
            <div class="input-group">
                <label for="outputPower">Output Power (Po) [W]:</label>
                <input type="number" id="outputPower" value="500" step="10">
            </div>
            <div class="input-group">
                <label for="primaryVoltageParallel">Primary Voltage (Vpp) [V]:</label>
                <input type="number" id="primaryVoltageParallel" value="80" step="5">
            </div>
            <div class="input-group">
                <label for="primaryVoltageSeries">Primary Voltage (Vps) [V]:</label>
                <input type="number" id="primaryVoltageSeries" value="160" step="5">
            </div>
            <div class="input-group">
                <label for="frequency">Frequency (f) [Hz]:</label>
                <input type="number" id="frequency" value="100000" step="1000">
            </div>
            <div class="input-group">
                <label for="voltageDrop">Voltage Drop (Vd) [V]:</label>
                <input type="number" id="voltageDrop" value="1.4" step="0.1">
            </div>
            <div class="input-group">
                <label for="dutyCycle">Duty Cycle (D):</label>
                <input type="number" id="dutyCycle" value="0.8" step="0.05">
            </div>
            <div class="input-group">
                <label for="maxPowerLoss">Max Power Loss (Ploss_max) [W]:</label>
                <input type="number" id="maxPowerLoss" value="20" step="1">
            </div>
            <div class="input-group">
                <label for="wireDiameterPrimary">Primary Wire Diameter (dps/dpp) [m]:</label>
                <input type="number" id="wireDiameterPrimary" value="0.0008" step="0.00001">
            </div>
            <div class="input-group">
                <label for="wireDiameterSecondary">Secondary Wire Diameter (ds) [m]:</label>
                <input type="number" id="wireDiameterSecondary" value="0.000812" step="0.00001">
            </div>
            <div class="input-group">
                <label for="ambientTemperature">Ambient Temperature (Tamb) [°C]:</label>
                <input type="number" id="ambientTemperature" value="25" step="1">
            </div>
            <div class="input-group">
                <label for="maxTemperature">Max Temperature (Tmax) [°C]:</label>
                <input type="number" id="maxTemperature" value="75" step="1">
            </div>
            <div class="input-group">
                <label for="coreType">Select Core Type:</label>
                <select id="coreType" class="w-full"></select>
            </div>
            <div class="input-group">
                <label for="plotType">Select Plot:</label>
                <select id="plotType" class="w-full">
                    <option value="loss_vs_flux">Core Loss vs Flux Density</option>
                    <option value="loss_vs_turns">Core Loss vs Turns</option>
                    <option value="flux_vs_turns">Flux Density vs Turns</option>
                    <option value="compare_core">Compare Core Losses</option>
                    <option value="layers_vs_turns">Number of Layers vs Turns</option>
                    <option value="skeff_proximity">Skeff & Proximity Effects</option>
                    <option value="copper_loss_vs_turns">Copper Loss vs Turns</option>
                    <option value="total_power_loss_vs_flux_series">Total Power Loss vs Flux Density (Series)</option>
                    <option value="total_power_loss_vs_flux_parallel">Total Power Loss vs Flux Density (Parallel)</option>
                    <option value="total_power_loss_vs_turns_series">Total Power Loss vs Turns (Series)</option>
                    <option value="total_power_loss_vs_turns_parallel">Total Power Loss vs Turns (Parallel)</option>
                    <option value="total_power_loss_vs_turns_combined">Total Power Loss vs Turns (Combined)</option>
                    <option value="ku_vs_turns">Ku vs Number of Primary Turns (Series)</option>
                    </select>
            </div>
        </div>
        
        <div class="flex justify-center mb-8">
            <button id="calculateButton" class="btn">Calculate and Plot</button>
        </div>

        <div id="plotDiv" class="plot-container">
            <div class="loading-overlay hidden" id="loadingOverlay">
                <div class="spinner"></div>
            </div>
            <p class="text-gray-500">Select parameters and click 'Calculate and Plot' to see results.</p>
        </div>

        <div id="lossDiffTableContainer" class="mt-8">
            <h2 class="text-2xl font-bold text-center text-gray-800 mb-4">Loss Difference Summary for All Cores</h2>
            <div id="lossDiffTable" class="overflow-x-auto">
                </div>
        </div>
    </div>

    <script>
        // Core Parameters and Constants (Translated from MATLAB)
        const colors = [
            [1, 0, 1], [1, 0, 0], [0, 1, 0], [0, 0, 1], [0, 1, 1],
            [0, 0, 0], [1, 0.5, 0], [0.5, 0, 0.5], [0.5, 0.5, 0], [0.2, 0.6, 1],
            [1, 0.2, 0.2], [0.3, 0.3, 0.3], [0.8, 0.4, 0]
        ];

        const core_names = ['EE10/11', 'EE13', 'EE16', 'EE19', 'EE25/19', 'EE30', 'EE40', 'EE50', 'EE60', 'ETD39', 'EE35', 'EE42', 'EE55'];
        const num_cores = core_names.length;

        const lms = [38.4, 45.4, 53.6, 66.8, 78.08, 94.2, 126.2, 156.2, 180.6, 149, 107.7, 144.55, 165.3].map(x => x * 1e-3);
        const Acs = [5.39, 8.82, 10, 11.96, 20.1528, 55, 66, 112.5, 123.2, 58.9, 45.2675, 118.69, 176.571].map(x => x * 1e-6);
        const Was = [46.62, 68.6, 82.8, 111.6, 158, 151.6, 328, 524, 814, 514, 93.7 * 2, 191.64 * 2, 331.82 * 2].map(x => x * 1e-6 / 2); // Divided by 2 as per MATLAB comments
        const MLTs = [12, 15.4, 14, 15, 19.18, 32, 34, 45, 47.4, 40.21, 29.32, 42.45, 51.46].map(x => x * 1e-3);
        const hs = [4.2 * 2, 4.6 * 2, 5.0 * 2, 5.6 * 2, 6.41 * 2, 8.15 * 2, 10.25 * 2, 12.75 * 2, 14.05 * 2, 14.6 * 2, 9.71 * 2, 15.15 * 2, 18.8 * 2].map(x => x * 1e-3 - 4e-3);
        const Vse = lms.map((lm, i) => lm * Acs[i]);

        const lmp = [52.2, 60.4, 69, 78.8, 97.4, 115.4, 154.6, 191.6, 220, 184.2, 127.12, 174.85, 202.9].map(x => x * 1e-3);
        const Acp = Acs;
        const Wap = Was;
        const MLTp = MLTs;
        const hp = hs;
        const Vsp = lmp.map((lm, i) => lm * Acp[i]);

        const Rths = [63.8, 62.5, 76, 60, 41.49, 21.80, 16.87, 11.2, 9.925, 16.40, 22.53, 11.42, 8.572];
        const Rthp = [63.8, 62.5, 76, 60, 36.82, 19.54, 15.12, 10.10, 8.921, 14.63, 20.63, 10.31, 7.674];

        // Main calculation function
        function calculateLosses() {
            // Read input parameters (these are common for all core calculations)
            const Po = parseFloat(document.getElementById('outputPower').value);
            const Vpp = parseFloat(document.getElementById('primaryVoltageParallel').value);
            const Vps = parseFloat(document.getElementById('primaryVoltageSeries').value);
            const f = parseFloat(document.getElementById('frequency').value);
            const Vd = parseFloat(document.getElementById('voltageDrop').value);
            const D = parseFloat(document.getElementById('dutyCycle').value);
            const Ploss_max = parseFloat(document.getElementById('maxPowerLoss').value);
            const ds = parseFloat(document.getElementById('wireDiameterSecondary').value);
            const dps = parseFloat(document.getElementById('wireDiameterPrimary').value); // dps and dpp are same as per MATLAB
            const dpp = dps;
            const Tamb = parseFloat(document.getElementById('ambientTemperature').value);
            const Tmax = parseFloat(document.getElementById('maxTemperature').value);

            const selectedCoreIndex = parseInt(document.getElementById('coreType').value);

            // Derived constants (these are common for all core calculations)
            const k = 0.160e3;
            const alpha = 1.078;
            const Beta = 2.92;
            const Vs1 = 24; // Fixed in MATLAB
            const Vs2 = 24; // Fixed in MATLAB
            const ns = 3; // Fixed in MATLAB
            const np = 3; // Fixed in MATLAB

            // Intermediate calculations (common for all core calculations)
            const I24 = Po / 2 / (Vs2 + 2 * Vd);
            const Isrms = ((Vs1 / Vps) * I24 + (Vs2 / Vps) * I24) * Math.sqrt(D);
            const Iprms = ((Vs1 / Vpp) * I24 + (Vs2 / Vpp) * I24) * Math.sqrt(D);
            const I01rms = (1 / 2) * (I24 * Math.sqrt(1 + D));

            const Awps = 2 * Math.PI * (dps / 2)**2;
            const Awpp = 2 * Math.PI * (dpp / 2)**2;
            const Aws = Math.PI * (ds / 2)**2; 

            const rho = 1.724e-8;
            const muc = 1.256629e-6;

            // Calculate wire parameters (these are global and don't depend on core)
            const Sd = Math.sqrt(rho * (1 + 0.0393 * (Tmax - 25)) / (Math.PI * f * muc));
            const nus = (Math.sqrt(Math.PI) * dps) / (2 * (dps + 0.051e-3));
            const nup = (Math.sqrt(Math.PI) * dpp) / (2 * (dpp + 0.051e-3));

            const deltaps = (Math.PI / 4)**0.75 * (dps / Sd) * Math.sqrt(nus);
            const deltapp = (Math.PI / 4)**0.75 * (dpp / Sd) * Math.sqrt(nup);
            const deltas = (Math.PI / 4)**0.75 * (ds / Sd) * Math.sqrt(nup); 

            const Skeffs = (Math.sinh(2 * deltaps) + Math.sin(2 * deltaps)) / (Math.cosh(2 * deltaps) - Math.cos(2 * deltaps));
            const Skeffp = (Math.sinh(2 * deltapp) + Math.sin(2 * deltapp)) / (Math.cosh(2 * deltapp) - Math.cos(2 * deltapp));
            const Proxeffs = (Math.sinh(deltaps) - Math.sin(deltaps)) / (Math.cosh(deltaps) + Math.cos(deltaps));
            const Proxeffp = (Math.sinh(deltapp) - Math.sin(deltapp)) / (Math.cosh(deltapp) + Math.cos(deltapp));

            // Initialize a structure to hold results for all cores for the summary table
            const allCoresLossSummary = [];

            // Initialize results for the currently selected core (for plotting)
            const selectedCoreResults = {
                selectedCoreIndex: selectedCoreIndex,
                Turns: { Series: { Primary: [], Secondary: [] }, Parallel: { Primary: [], Secondary: [] } },
                Flux: { Series: [], Parallel: [] },
                Pfes: [], Pfep: [],
                Layers: { Series: { Primary: [], Secondary: [] }, Parallel: { Primary: [], Secondary: [] } },
                Lfactor: { Series: { Primary: [], Secondary: [] }, Parallel: { Primary: [], Secondary: [] } },
                Fr: { Series: { Primary: [], Secondary: [] }, Parallel: { Primary: [], Secondary: [] } },
                Resistance: { Series: { Primary: [], Secondary: [] }, Parallel: { Primary: [], Secondary: [] } },
                CopperLoss: { Series: [], Parallel: [] },
                PowerLoss: { Series: [], Parallel: [] },
                FillFactor: { Series: [] },
                Ku: { Series: [] },
                Optimal: {
                    Series: { Power: NaN, B: NaN, Np: NaN },
                    Parallel: { Power: NaN, B: NaN, Np: NaN }
                },
                Pmaxs: NaN,
                Pmaxp: NaN
            };

            // Loop through all cores to calculate summary data
            for (let i = 0; i < num_cores; i++) {
                const current_lms = lms[i];
                const current_Acs = Acs[i];
                const current_Was = Was[i];
                const current_MLTs = MLTs[i];
                const current_hs = hs[i];
                const current_Vse = Vse[i];

                const current_lmp = lmp[i];
                const current_Acp = Acp[i];
                const current_Wap = Wap[i];
                const current_MLTp = MLTp[i];
                const current_hp = hp[i];
                const current_Vsp = Vsp[i];

                const current_Rths = Rths[i];
                const current_Rthp = Rthp[i];

                const Pmax_series_core = (Tmax - Tamb) / current_Rths;
                const Pmax_parallel_core = (Tmax - Tamb) / current_Rthp;

                const Bsmax_core = (Pmax_series_core / (k * f**alpha * current_Vse))**(1/Beta);
                const Bpmax_core = (Pmax_parallel_core / (k * f**alpha * current_Vsp))**(1/Beta);

                const Npsmax_core = (0.78 * current_Was) / (Awps + Aws / ns);
                const Nppmax_core = (0.78 * current_Wap) / (Awpp + Aws / np);

                // Calculate turns ranges for current core
                let Nps_range_core = [];
                const Nps_min_core = Math.ceil((0.5 * Vps * D) / (current_Acs * f * 2 * Bsmax_core));
                for (let n = Nps_min_core; n <= Npsmax_core; n++) { Nps_range_core.push(n); }

                let Npp_range_core = [];
                const Npp_min_core = Math.ceil((Vpp * D) / (current_Acp * f * 2 * Bpmax_core));
                for (let n = Npp_min_core; n <= Nppmax_core; n++) { Npp_range_core.push(n); }

                const B_series_full_core = Nps_range_core.map(Np => (0.5 * Vps * D) / (2 * current_Acs * f * Np));
                const B_parallel_full_core = Npp_range_core.map(Np => (Vpp * D) / (2 * current_Acp * f * Np));

                const valid_idx_series_core = B_series_full_core.map(B => B <= Bsmax_core);
                const valid_idx_parallel_core = B_parallel_full_core.map(B => B <= Bpmax_core);

                const B_series_core = B_series_full_core.filter((_, idx) => valid_idx_series_core[idx]);
                const B_parallel_core = B_parallel_full_core.filter((_, idx) => valid_idx_parallel_core[idx]);
                const Nps_valid_core = Nps_range_core.filter((_, idx) => valid_idx_series_core[idx]);
                const Npp_valid_core = Npp_range_core.filter((_, idx) => valid_idx_parallel_core[idx]);

                const Pfes_core = B_series_core.map(B => k * f**alpha * B**Beta * current_Acs * current_lms);
                const Pfep_core = B_parallel_core.map(B => k * f**alpha * B**Beta * current_Acp * current_lmp);

                const Ns_series_core = Nps_valid_core.map(Np => Np / ns);
                const Ns_parallel_core = Npp_valid_core.map(Np => Np / np);

                const Lfactor_series_primary_core = Nps_valid_core.map(Np => (2 * (Math.max((0.5 * Np * dps) / current_hs, 1)**2) - 1) / 3);
                const Lfactor_series_secondary_core = Ns_series_core.map(Ns => (2 * (Math.max((0.5 * Ns * ds) / current_hs, 1)**2) - 1) / 3);
                const Lfactor_parallel_primary_core = Npp_valid_core.map(Np => (2 * (Math.max((0.5 * Np * dpp) / current_hp, 1)**2) - 1) / 3);
                const Lfactor_parallel_secondary_core = Ns_parallel_core.map(Ns => (2 * (Math.max((0.5 * Ns * ds) / current_hp, 1)**2) - 1) / 3);

                const Fr_series_primary_core = Lfactor_series_primary_core.map(Lfactor => deltaps * (Skeffs + Lfactor * Proxeffs));
                const Fr_series_secondary_core = Lfactor_series_secondary_core.map(Lfactor => deltas * (Skeffs + Lfactor * Proxeffs));
                const Fr_parallel_primary_core = Lfactor_parallel_primary_core.map(Lfactor => deltapp * (Skeffp + Lfactor * Proxeffp));
                const Fr_parallel_secondary_core = Lfactor_parallel_secondary_core.map(Lfactor => deltas * (Skeffp + Lfactor * Proxeffp));

                const Resistance_series_primary_core = Fr_series_primary_core.map((Fr, idx) => Fr * Nps_valid_core[idx] * (rho / Awps) * current_MLTs);
                const Resistance_series_secondary_core = Fr_series_secondary_core.map((Fr, idx) => Fr * Ns_series_core[idx] * (rho / Aws) * current_MLTs);
                const Resistance_parallel_primary_core = Fr_parallel_primary_core.map((Fr, idx) => Fr * Npp_valid_core[idx] * (rho / Awpp) * current_MLTp);
                const Resistance_parallel_secondary_core = Fr_parallel_secondary_core.map((Fr, idx) => Fr * Ns_parallel_core[idx] * (rho / Aws) * current_MLTp);

                const CopperLoss_series_core = Resistance_series_primary_core.map((R_p, idx) => R_p * Isrms**2 + Resistance_series_secondary_core[idx] * I01rms**2);
                const CopperLoss_parallel_core = Resistance_parallel_primary_core.map((R_p, idx) => 0.5 * R_p * (0.5 * Iprms)**2 + Resistance_parallel_secondary_core[idx] * I01rms**2);

                const PowerLoss_series_core = CopperLoss_series_core.map((Closs, idx) => Closs + Pfes_core[idx]);
                const PowerLoss_parallel_core = CopperLoss_parallel_core.map((Closs, idx) => Closs + Pfep_core[idx]);

                let optimalSeriesPower = NaN;
                let optimalSeriesNp = NaN;
                if (PowerLoss_series_core && PowerLoss_series_core.length > 0) {
                    let minLossIdx = 0;
                    for (let j = 0; j < PowerLoss_series_core.length; j++) {
                        if (PowerLoss_series_core[j] < PowerLoss_series_core[minLossIdx]) {
                            minLossIdx = j;
                        }
                    }
                    optimalSeriesPower = PowerLoss_series_core[minLossIdx];
                    optimalSeriesNp = Nps_valid_core[minLossIdx];
                }

                let optimalParallelPower = NaN;
                let optimalParallelNp = NaN;
                if (PowerLoss_parallel_core && PowerLoss_parallel_core.length > 0) {
                    let minLossIdx = 0;
                    for (let j = 0; j < PowerLoss_parallel_core.length; j++) {
                        if (PowerLoss_parallel_core[j] < PowerLoss_parallel_core[minLossIdx]) {
                            minLossIdx = j;
                        }
                    }
                    optimalParallelPower = PowerLoss_parallel_core[minLossIdx];
                    optimalParallelNp = Npp_valid_core[minLossIdx];
                }

                allCoresLossSummary.push({
                    coreName: core_names[i],
                    Pmaxs: Pmax_series_core,
                    OptimalSeriesPower: optimalSeriesPower,
                    OptimalSeriesNp: optimalSeriesNp, // Added optimal Np for series
                    Pmaxp: Pmax_parallel_core,
                    OptimalParallelPower: optimalParallelPower,
                    OptimalParallelNp: optimalParallelNp // Added optimal Np for parallel
                });

                // If this is the selected core, populate selectedCoreResults for plotting
                if (i === selectedCoreIndex) {
                    selectedCoreResults.Turns.Series.Primary = Nps_valid_core;
                    selectedCoreResults.Turns.Parallel.Primary = Npp_valid_core;
                    selectedCoreResults.Flux.Series = B_series_core;
                    selectedCoreResults.Flux.Parallel = B_parallel_core;
                    selectedCoreResults.Pfes = Pfes_core;
                    selectedCoreResults.Pfep = Pfep_core;
                    
                    selectedCoreResults.Turns.Series.Secondary = Ns_series_core;
                    selectedCoreResults.Turns.Parallel.Secondary = Ns_parallel_core;

                    selectedCoreResults.Layers.Series.Primary = Nps_valid_core.map(Np => Math.max((0.5 * Np * dps) / current_hs, 1));
                    selectedCoreResults.Layers.Series.Secondary = Ns_series_core.map(Ns => Math.max((0.5 * Ns * ds) / current_hs, 1));
                    selectedCoreResults.Layers.Parallel.Primary = Npp_valid_core.map(Np => Math.max((0.5 * Np * dpp) / current_hp, 1));
                    selectedCoreResults.Layers.Parallel.Secondary = Ns_parallel_core.map(Ns => Math.max((0.5 * Ns * ds) / current_hp, 1));

                    selectedCoreResults.Lfactor.Series.Primary = Lfactor_series_primary_core;
                    selectedCoreResults.Lfactor.Series.Secondary = Lfactor_series_secondary_core;
                    selectedCoreResults.Lfactor.Parallel.Primary = Lfactor_parallel_primary_core;
                    selectedCoreResults.Lfactor.Parallel.Secondary = Lfactor_parallel_secondary_core;

                    selectedCoreResults.Fr.Series.Primary = Fr_series_primary_core;
                    selectedCoreResults.Fr.Series.Secondary = Fr_series_secondary_core;
                    selectedCoreResults.Fr.Parallel.Primary = Fr_parallel_primary_core;
                    selectedCoreResults.Fr.Parallel.Secondary = Fr_parallel_secondary_core;

                    selectedCoreResults.Resistance.Series.Primary = Resistance_series_primary_core;
                    selectedCoreResults.Resistance.Series.Secondary = Resistance_series_secondary_core;
                    selectedCoreResults.Resistance.Parallel.Primary = Resistance_parallel_primary_core;
                    selectedCoreResults.Resistance.Parallel.Secondary = Resistance_parallel_secondary_core;

                    selectedCoreResults.CopperLoss.Series = CopperLoss_series_core;
                    selectedCoreResults.CopperLoss.Parallel = CopperLoss_parallel_core;
                    selectedCoreResults.PowerLoss.Series = PowerLoss_series_core;
                    selectedCoreResults.PowerLoss.Parallel = PowerLoss_parallel_core;

                    // Recalculate Ku for the selected core
                    const t_ins = 0.051e-3; // Interlayer insulation thickness (m)
                    const d_barep = 0.4e-3;
                    const d_insulatedp = 0.442e-3;
                    const A_copperp = 2 * Math.PI * (d_barep / 2)**2; 
                    const A_total_wirep = Math.PI * (d_insulatedp / 2)**2;
                    const d_bares = 0.812e-3;
                    const d_insulateds = 1.082e-3;
                    const A_coppers = Math.PI * (d_bares / 2)**2;
                    const A_total_wires = Math.PI * (d_insulateds / 2)**2;
                    const A_total_wire = A_total_wirep + A_total_wires;
                    const S1 = (A_copperp + A_coppers) / A_total_wire;

                    selectedCoreResults.FillFactor.Series = [];
                    selectedCoreResults.Ku.Series = [];

                    const h = current_hs;
                    const margin = 1.5e-3;
                    const top_clearance = 1e-3;
                    const bottom_clearance = 1e-3;
                    const usable_width = current_Was / h;
                    const usable_width_eff = usable_width - margin;
                    const usable_height_eff = h - top_clearance - bottom_clearance;
                    const A_usable_window = usable_width_eff * usable_height_eff;
                    const S3 = (usable_width_eff * usable_height_eff) / (usable_width * h);

                    for (let j = 0; j < Nps_valid_core.length; j++) {
                        const Np = Nps_valid_core[j];
                        const Ns = Ns_series_core[j];
                        const Nlp = selectedCoreResults.Layers.Series.Primary[j];
                        const Nls = selectedCoreResults.Layers.Series.Secondary[j];

                        const Awp_total = Np * Awps;
                        const Aws_total = Ns * Aws;
                        const A_copper_total = Awp_total + Aws_total;

                        const A_allocated = current_Was - (current_Was - A_copper_total);
                        const S2_dynamic = A_copper_total / A_allocated;
                        const layer_penalty = 1 - 0.02 * (Nlp + Nls - 1);
                        const S2 = Math.max(Math.min(S2_dynamic * layer_penalty, 1), 0);

                        const A_ins = (Nlp + Nls - 1) * t_ins * h;
                        const S4 = A_usable_window / (A_usable_window + A_ins);

                        const ku_dynamic = S1 * S2 * S3 * S4;
                        selectedCoreResults.Ku.Series.push(ku_dynamic);
                        selectedCoreResults.FillFactor.Series.push(ku_dynamic);
                    }

                    // Optimal points calculation for selected core
                    selectedCoreResults.Optimal.Series.Power = optimalSeriesPower;
                    selectedCoreResults.Optimal.Series.Np = optimalSeriesNp;
                    selectedCoreResults.Optimal.Parallel.Power = optimalParallelPower;
                    selectedCoreResults.Optimal.Parallel.Np = optimalParallelNp;
                    
                    if (selectedCoreResults.PowerLoss.Series && selectedCoreResults.PowerLoss.Series.length > 0) {
                        let minLossIdx = 0;
                        for (let j = 0; j < selectedCoreResults.PowerLoss.Series.length; j++) {
                            if (selectedCoreResults.PowerLoss.Series[j] < selectedCoreResults.PowerLoss.Series[minLossIdx]) {
                                minLossIdx = j;
                            }
                        }
                        selectedCoreResults.Optimal.Series.B = selectedCoreResults.Flux.Series[minLossIdx];
                    } else {
                        selectedCoreResults.Optimal.Series.B = NaN;
                    }

                    if (selectedCoreResults.PowerLoss.Parallel && selectedCoreResults.PowerLoss.Parallel.length > 0) {
                        let minLossIdx = 0;
                        for (let j = 0; j < selectedCoreResults.PowerLoss.Parallel.length; j++) {
                            if (selectedCoreResults.PowerLoss.Parallel[j] < selectedCoreResults.PowerLoss.Parallel[minLossIdx]) {
                                minLossIdx = j;
                            }
                        }
                        selectedCoreResults.Optimal.Parallel.B = selectedCoreResults.Flux.Parallel[minLossIdx];
                    } else {
                        selectedCoreResults.Optimal.Parallel.B = NaN;
                    }

                    selectedCoreResults.Pmaxs = Pmax_series_core;
                    selectedCoreResults.Pmaxp = Pmax_parallel_core;
                }
            }

            // Log the valid turns arrays for debugging
            console.log("Nps_valid_core for selected core:", selectedCoreResults.Turns.Series.Primary);
            console.log("Npp_valid_core for selected core:", selectedCoreResults.Turns.Parallel.Primary);
            console.log("PowerLoss.Series for selected core:", selectedCoreResults.PowerLoss.Series);
            console.log("PowerLoss.Parallel for selected core:", selectedCoreResults.PowerLoss.Parallel);


            // Return both the selected core's detailed results and the summary for all cores
            return { selectedCoreResults, allCoresLossSummary };
        }

        // Helper function to get Plotly color string from RGB array
        function getPlotlyColor(rgbArray) {
            return `rgb(${rgbArray[0]*255},${rgbArray[1]*255},${rgbArray[2]*255})`;
        }

        // Plotting functions (translated from MATLAB's plotCoreLosses cases)
        function plotLossVsFlux(data, plotDivId) {
            const traces = [];
            const colorMap = colors.map(c => getPlotlyColor(c));
            const selectedCoreName = core_names[data.selectedCoreIndex];

            // Plot Series (solid line)
            if (data.Flux.Series && data.Pfes && data.Flux.Series.length > 0 && data.Flux.Series.every(val => !isNaN(val)) && data.Pfes.every(val => !isNaN(val))) {
                traces.push({
                    x: data.Flux.Series,
                    y: data.Pfes,
                    mode: 'lines',
                    name: `${selectedCoreName}-S`,
                    line: { color: colorMap[data.selectedCoreIndex % colors.length], width: 2 }
                });
            }
            // Plot Parallel (dashed line)
            if (data.Flux.Parallel && data.Pfep && data.Flux.Parallel.length > 0 && data.Flux.Parallel.every(val => !isNaN(val)) && data.Pfep.every(val => !isNaN(val))) {
                traces.push({
                    x: data.Flux.Parallel,
                    y: data.Pfep,
                    mode: 'lines',
                    name: `${selectedCoreName}-P`,
                    line: { color: colorMap[data.selectedCoreIndex % colors.length], width: 2, dash: 'dash' }
                });
            }

            const layout = {
                title: `Core Loss vs. Flux Density for ${selectedCoreName}`,
                xaxis: { title: 'Flux Density (B) [T]' },
                yaxis: { title: 'Core Loss (Pfe) [W]' },
                hovermode: 'closest'
            };

            Plotly.newPlot(plotDivId, traces, layout);
        }

        function plotLossVsTurns(data, plotDivId) {
            const traces = [];
            const colorMap = colors.map(c => getPlotlyColor(c));
            const selectedCoreName = core_names[data.selectedCoreIndex];

            if (data.Turns.Series.Primary && data.Pfes && data.Turns.Series.Primary.length > 0 && data.Pfes.length > 0) {
                traces.push({
                    x: data.Turns.Series.Primary,
                    y: data.Pfes,
                    mode: 'lines',
                    name: `${selectedCoreName}-S`,
                    line: { color: colorMap[data.selectedCoreIndex % colors.length], width: 2 }
                });
            }
            if (data.Turns.Parallel.Primary && data.Pfep && data.Turns.Parallel.Primary.length > 0 && data.Pfep.length > 0) {
                traces.push({
                    x: data.Turns.Parallel.Primary,
                    y: data.Pfep,
                    mode: 'lines',
                    name: `${selectedCoreName}-P`,
                    line: { color: colorMap[data.selectedCoreIndex % colors.length], width: 2, dash: 'dash' }
                });
            }

            const layout = {
                title: `Core Loss vs. Turns for ${selectedCoreName}`,
                xaxis: { title: 'Number of Primary Turns (Np)' },
                yaxis: { title: 'Core Loss (Pfe) [W]' },
                hovermode: 'closest'
            };

            Plotly.newPlot(plotDivId, traces, layout);
        }

        function plotFluxVsTurns(data, plotDivId) {
            const traces = [];
            const colorMap = colors.map(c => getPlotlyColor(c));
            const selectedCoreName = core_names[data.selectedCoreIndex];

            if (data.Turns.Series.Primary && data.Flux.Series && data.Turns.Series.Primary.length > 0 && data.Flux.Series.length > 0) {
                traces.push({
                    x: data.Turns.Series.Primary,
                    y: data.Flux.Series,
                    mode: 'lines',
                    name: `${selectedCoreName}-S`,
                    line: { color: colorMap[data.selectedCoreIndex % colors.length], width: 2 }
                });
            }
            if (data.Turns.Parallel.Primary && data.Flux.Parallel && data.Turns.Parallel.Primary.length > 0 && data.Flux.Parallel.length > 0) {
                traces.push({
                    x: data.Turns.Parallel.Primary,
                    y: data.Flux.Parallel,
                    mode: 'lines',
                    name: `${selectedCoreName}-P`,
                    line: { color: colorMap[data.selectedCoreIndex % colors.length], width: 2, dash: 'dash' }
                });
            }

            const layout = {
                title: `Flux Density vs. Turns for ${selectedCoreName}`,
                xaxis: { title: 'Number of Primary Turns (Np)' },
                yaxis: { title: 'Flux Density (B) [T]' },
                hovermode: 'closest'
            };

            Plotly.newPlot(plotDivId, traces, layout);
        }

        function plotCompareCoreLosses(allCoresData, plotDivId) {
            const traces = [];
            const colorMap = colors.map(c => getPlotlyColor(c));

            allCoresData.forEach((coreData, index) => {
                if (coreData.OptimalSeriesPower && !isNaN(coreData.OptimalSeriesPower)) {
                    traces.push({
                        x: [core_names[index]],
                        y: [coreData.OptimalSeriesPower],
                        type: 'bar',
                        name: `${core_names[index]} (Series)`,
                        marker: { color: colorMap[index % colors.length] }
                    });
                }
                if (coreData.OptimalParallelPower && !isNaN(coreData.OptimalParallelPower)) {
                    traces.push({
                        x: [core_names[index]],
                        y: [coreData.OptimalParallelPower],
                        type: 'bar',
                        name: `${core_names[index]} (Parallel)`,
                        marker: { color: colorMap[index % colors.length], pattern: { shape: '/' } } // Add a pattern for parallel
                    });
                }
            });

            const layout = {
                title: 'Optimal Power Loss Comparison Across Cores',
                xaxis: { title: 'Core Type' },
                yaxis: { title: 'Optimal Power Loss [W]' },
                barmode: 'group',
                hovermode: 'closest'
            };

            Plotly.newPlot(plotDivId, traces, layout);
        }

        function plotLayersVsTurns(data, plotDivId) {
            const traces = [];
            const colorMap = colors.map(c => getPlotlyColor(c));
            const selectedCoreName = core_names[data.selectedCoreIndex];

            // Primary Series Layers
            if (data.Turns.Series.Primary && data.Layers.Series.Primary && data.Turns.Series.Primary.length > 0 && data.Layers.Series.Primary.length > 0) {
                traces.push({
                    x: data.Turns.Series.Primary,
                    y: data.Layers.Series.Primary,
                    mode: 'lines',
                    name: `${selectedCoreName}-S Primary Layers`,
                    line: { color: colorMap[data.selectedCoreIndex % colors.length], width: 2 }
                });
            }
            // Secondary Series Layers
            if (data.Turns.Series.Secondary && data.Layers.Series.Secondary && data.Turns.Series.Secondary.length > 0 && data.Layers.Series.Secondary.length > 0) {
                traces.push({
                    x: data.Turns.Series.Primary, // X-axis is primary turns
                    y: data.Layers.Series.Secondary,
                    mode: 'lines',
                    name: `${selectedCoreName}-S Secondary Layers`,
                    line: { color: colorMap[data.selectedCoreIndex % colors.length], width: 2, dash: 'dot' }
                });
            }
            // Primary Parallel Layers
            if (data.Turns.Parallel.Primary && data.Layers.Parallel.Primary && data.Turns.Parallel.Primary.length > 0 && data.Layers.Parallel.Primary.length > 0) {
                traces.push({
                    x: data.Turns.Parallel.Primary,
                    y: data.Layers.Parallel.Primary,
                    mode: 'lines',
                    name: `${selectedCoreName}-P Primary Layers`,
                    line: { color: colorMap[data.selectedCoreIndex % colors.length], width: 2, dash: 'dash' }
                });
            }
            // Secondary Parallel Layers
            if (data.Turns.Parallel.Secondary && data.Layers.Parallel.Secondary && data.Turns.Parallel.Secondary.length > 0 && data.Layers.Parallel.Secondary.length > 0) {
                traces.push({
                    x: data.Turns.Parallel.Primary, // X-axis is primary turns
                    y: data.Layers.Parallel.Secondary,
                    mode: 'lines',
                    name: `${selectedCoreName}-P Secondary Layers`,
                    line: { color: colorMap[data.selectedCoreIndex % colors.length], width: 2, dash: 'longdashdot' }
                });
            }

            const layout = {
                title: `Number of Layers vs. Turns for ${selectedCoreName}`,
                xaxis: { title: 'Number of Primary Turns (Np)' },
                yaxis: { title: 'Number of Layers' },
                hovermode: 'closest'
            };

            Plotly.newPlot(plotDivId, traces, layout);
        }

        function plotSkeffProximity(data, plotDivId) {
            const traces = [];
            const selectedCoreName = core_names[data.selectedCoreIndex];

            // Skeffs (Series Primary)
            if (data.Turns.Series.Primary && data.Fr.Series.Primary && data.Turns.Series.Primary.length > 0 && data.Fr.Series.Primary.length > 0) {
                traces.push({
                    x: data.Turns.Series.Primary,
                    y: data.Fr.Series.Primary.map(val => data.Skeffs), // Skeffs is a constant
                    mode: 'lines',
                    name: `Skeff (Series Primary)`,
                    line: { color: 'blue', width: 2 }
                });
            }
            // Proxeffs (Series Primary)
            if (data.Turns.Series.Primary && data.Fr.Series.Primary && data.Turns.Series.Primary.length > 0 && data.Fr.Series.Primary.length > 0) {
                traces.push({
                    x: data.Turns.Series.Primary,
                    y: data.Fr.Series.Primary.map(val => data.Proxeffs), // Proxeffs is a constant
                    mode: 'lines',
                    name: `Proxeff (Series Primary)`,
                    line: { color: 'red', width: 2 }
                });
            }

            // Fr (Series Primary)
            if (data.Turns.Series.Primary && data.Fr.Series.Primary && data.Turns.Series.Primary.length > 0 && data.Fr.Series.Primary.length > 0) {
                traces.push({
                    x: data.Turns.Series.Primary,
                    y: data.Fr.Series.Primary,
                    mode: 'lines',
                    name: `Fr (Series Primary)`,
                    line: { color: 'green', width: 2 }
                });
            }

            const layout = {
                title: `Skin Effect (Skeff) and Proximity Effect (Proxeff) for ${selectedCoreName} (Series Primary)`,
                xaxis: { title: 'Number of Primary Turns (Np)' },
                yaxis: { title: 'Effect Factor' },
                hovermode: 'closest'
            };

            Plotly.newPlot(plotDivId, traces, layout);
        }

        function plotCopperLossVsTurns(data, plotDivId) {
            const traces = [];
            const colorMap = colors.map(c => getPlotlyColor(c));
            const selectedCoreName = core_names[data.selectedCoreIndex];

            if (data.Turns.Series.Primary && data.CopperLoss.Series && data.Turns.Series.Primary.length > 0 && data.CopperLoss.Series.length > 0) {
                traces.push({
                    x: data.Turns.Series.Primary,
                    y: data.CopperLoss.Series,
                    mode: 'lines',
                    name: `${selectedCoreName}-S Copper Loss`,
                    line: { color: colorMap[data.selectedCoreIndex % colors.length], width: 2 }
                });
            }
            if (data.Turns.Parallel.Primary && data.CopperLoss.Parallel && data.Turns.Parallel.Primary.length > 0 && data.CopperLoss.Parallel.length > 0) {
                traces.push({
                    x: data.Turns.Parallel.Primary,
                    y: data.CopperLoss.Parallel,
                    mode: 'lines',
                    name: `${selectedCoreName}-P Copper Loss`,
                    line: { color: colorMap[data.selectedCoreIndex % colors.length], width: 2, dash: 'dash' }
                });
            }

            const layout = {
                title: `Copper Loss vs. Turns for ${selectedCoreName}`,
                xaxis: { title: 'Number of Primary Turns (Np)' },
                yaxis: { title: 'Copper Loss [W]' },
                hovermode: 'closest'
            };

            Plotly.newPlot(plotDivId, traces, layout);
        }

        function plotTotalPowerLossVsFluxSeries(data, plotDivId) {
            const traces = [];
            const colorMap = colors.map(c => getPlotlyColor(c));
            const selectedCoreName = core_names[data.selectedCoreIndex];

            if (data.Flux.Series && data.PowerLoss.Series && data.Flux.Series.length > 0 && data.PowerLoss.Series.length > 0) {
                traces.push({
                    x: data.Flux.Series,
                    y: data.PowerLoss.Series,
                    mode: 'lines',
                    name: `${selectedCoreName}-S Total Power Loss`,
                    line: { color: colorMap[data.selectedCoreIndex % colors.length], width: 2 }
                });
                // Add the Pmaxs line
                if (!isNaN(data.Pmaxs)) {
                    traces.push({
                        x: [Math.min(...data.Flux.Series), Math.max(...data.Flux.Series)],
                        y: [data.Pmaxs, data.Pmaxs],
                        mode: 'lines',
                        name: 'Pmax_series',
                        line: { color: 'red', dash: 'dash', width: 2 }
                    });
                }
                // Add optimal point marker
                if (!isNaN(data.Optimal.Series.B) && !isNaN(data.Optimal.Series.Power)) {
                    traces.push({
                        x: [data.Optimal.Series.B],
                        y: [data.Optimal.Series.Power],
                        mode: 'markers',
                        name: `Optimal S (${data.Optimal.Series.Np})`,
                        marker: { color: 'green', size: 10, symbol: 'star' }
                    });
                }
            }

            const layout = {
                title: `Total Power Loss vs. Flux Density (Series) for ${selectedCoreName}`,
                xaxis: { title: 'Flux Density (B) [T]' },
                yaxis: { title: 'Total Power Loss [W]' },
                hovermode: 'closest'
            };

            Plotly.newPlot(plotDivId, traces, layout);
        }

        function plotTotalPowerLossVsFluxParallel(data, plotDivId) {
            const traces = [];
            const colorMap = colors.map(c => getPlotlyColor(c));
            const selectedCoreName = core_names[data.selectedCoreIndex];

            if (data.Flux.Parallel && data.PowerLoss.Parallel && data.Flux.Parallel.length > 0 && data.PowerLoss.Parallel.length > 0) {
                traces.push({
                    x: data.Flux.Parallel,
                    y: data.PowerLoss.Parallel,
                    mode: 'lines',
                    name: `${selectedCoreName}-P Total Power Loss`,
                    line: { color: colorMap[data.selectedCoreIndex % colors.length], width: 2, dash: 'dash' }
                });
                // Add the Pmaxp line
                if (!isNaN(data.Pmaxp)) {
                    traces.push({
                        x: [Math.min(...data.Flux.Parallel), Math.max(...data.Flux.Parallel)],
                        y: [data.Pmaxp, data.Pmaxp],
                        mode: 'lines',
                        name: 'Pmax_parallel',
                        line: { color: 'red', dash: 'dash', width: 2 }
                    });
                }
                // Add optimal point marker
                if (!isNaN(data.Optimal.Parallel.B) && !isNaN(data.Optimal.Parallel.Power)) {
                    traces.push({
                        x: [data.Optimal.Parallel.B],
                        y: [data.Optimal.Parallel.Power],
                        mode: 'markers',
                        name: `Optimal P (${data.Optimal.Parallel.Np})`,
                        marker: { color: 'purple', size: 10, symbol: 'star' }
                    });
                }
            }

            const layout = {
                title: `Total Power Loss vs. Flux Density (Parallel) for ${selectedCoreName}`,
                xaxis: { title: 'Flux Density (B) [T]' },
                yaxis: { title: 'Total Power Loss [W]' },
                hovermode: 'closest'
            };

            Plotly.newPlot(plotDivId, traces, layout);
        }

        function plotTotalPowerLossVsTurnsSeries(data, plotDivId) {
            const traces = [];
            const colorMap = colors.map(c => getPlotlyColor(c));
            const selectedCoreName = core_names[data.selectedCoreIndex];

            if (data.Turns.Series.Primary && data.PowerLoss.Series && data.Turns.Series.Primary.length > 0 && data.PowerLoss.Series.length > 0) {
                traces.push({
                    x: data.Turns.Series.Primary,
                    y: data.PowerLoss.Series,
                    mode: 'lines',
                    name: `${selectedCoreName}-S Total Power Loss`,
                    line: { color: colorMap[data.selectedCoreIndex % colors.length], width: 2 }
                });
                // Add the Pmaxs line
                if (!isNaN(data.Pmaxs)) {
                    traces.push({
                        x: [Math.min(...data.Turns.Series.Primary), Math.max(...data.Turns.Series.Primary)],
                        y: [data.Pmaxs, data.Pmaxs],
                        mode: 'lines',
                        name: 'Pmax_series',
                        line: { color: 'red', dash: 'dash', width: 2 }
                    });
                }
                // Add optimal point marker
                if (!isNaN(data.Optimal.Series.Np) && !isNaN(data.Optimal.Series.Power)) {
                    traces.push({
                        x: [data.Optimal.Series.Np],
                        y: [data.Optimal.Series.Power],
                        mode: 'markers',
                        name: `Optimal S (${data.Optimal.Series.Np})`,
                        marker: { color: 'green', size: 10, symbol: 'star' }
                    });
                }
            }

            const layout = {
                title: `Total Power Loss vs. Turns (Series) for ${selectedCoreName}`,
                xaxis: { title: 'Number of Primary Turns (Np)' },
                yaxis: { title: 'Total Power Loss [W]' },
                hovermode: 'closest'
            };

            Plotly.newPlot(plotDivId, traces, layout);
        }

        function plotTotalPowerLossVsTurnsParallel(data, plotDivId) {
            const traces = [];
            const colorMap = colors.map(c => getPlotlyColor(c));
            const selectedCoreName = core_names[data.selectedCoreIndex];

            if (data.Turns.Parallel.Primary && data.PowerLoss.Parallel && data.Turns.Parallel.Primary.length > 0 && data.PowerLoss.Parallel.length > 0) {
                traces.push({
                    x: data.Turns.Parallel.Primary,
                    y: data.PowerLoss.Parallel,
                    mode: 'lines',
                    name: `${selectedCoreName}-P Total Power Loss`,
                    line: { color: colorMap[data.selectedCoreIndex % colors.length], width: 2, dash: 'dash' }
                });
                // Add the Pmaxp line
                if (!isNaN(data.Pmaxp)) {
                    traces.push({
                        x: [Math.min(...data.Turns.Parallel.Primary), Math.max(...data.Turns.Parallel.Primary)],
                        y: [data.Pmaxp, data.Pmaxp],
                        mode: 'lines',
                        name: 'Pmax_parallel',
                        line: { color: 'red', dash: 'dash', width: 2 }
                    });
                }
                // Add optimal point marker
                if (!isNaN(data.Optimal.Parallel.Np) && !isNaN(data.Optimal.Parallel.Power)) {
                    traces.push({
                        x: [data.Optimal.Parallel.Np],
                        y: [data.Optimal.Parallel.Power],
                        mode: 'markers',
                        name: `Optimal P (${data.Optimal.Parallel.Np})`,
                        marker: { color: 'purple', size: 10, symbol: 'star' }
                    });
                }
            }

            const layout = {
                title: `Total Power Loss vs. Turns (Parallel) for ${selectedCoreName}`,
                xaxis: { title: 'Number of Primary Turns (Np)' },
                yaxis: { title: 'Total Power Loss [W]' },
                hovermode: 'closest'
            };

            Plotly.newPlot(plotDivId, traces, layout);
        }

        function plotTotalPowerLossVsTurnsCombined(data, plotDivId) {
            const traces = [];
            const colorMap = colors.map(c => getPlotlyColor(c));
            const selectedCoreName = core_names[data.selectedCoreIndex];

            // Series data
            if (data.Turns.Series.Primary && data.PowerLoss.Series && data.Turns.Series.Primary.length > 0 && data.PowerLoss.Series.length > 0) {
                traces.push({
                    x: data.Turns.Series.Primary,
                    y: data.PowerLoss.Series,
                    mode: 'lines',
                    name: `${selectedCoreName}-S Total Power Loss`,
                    line: { color: colorMap[data.selectedCoreIndex % colors.length], width: 2 }
                });
                if (!isNaN(data.Pmaxs)) {
                    traces.push({
                        x: [Math.min(...data.Turns.Series.Primary), Math.max(...data.Turns.Series.Primary)],
                        y: [data.Pmaxs, data.Pmaxs],
                        mode: 'lines',
                        name: 'Pmax_series',
                        line: { color: 'red', dash: 'dash', width: 2 }
                    });
                }
                if (!isNaN(data.Optimal.Series.Np) && !isNaN(data.Optimal.Series.Power)) {
                    traces.push({
                        x: [data.Optimal.Series.Np],
                        y: [data.Optimal.Series.Power],
                        mode: 'markers',
                        name: `Optimal S (${data.Optimal.Series.Np})`,
                        marker: { color: 'green', size: 10, symbol: 'star' }
                    });
                }
            }

            // Parallel data
            if (data.Turns.Parallel.Primary && data.PowerLoss.Parallel && data.Turns.Parallel.Primary.length > 0 && data.PowerLoss.Parallel.length > 0) {
                traces.push({
                    x: data.Turns.Parallel.Primary,
                    y: data.PowerLoss.Parallel,
                    mode: 'lines',
                    name: `${selectedCoreName}-P Total Power Loss`,
                    line: { color: colorMap[data.selectedCoreIndex % colors.length], width: 2, dash: 'dash' }
                });
                if (!isNaN(data.Pmaxp)) {
                    traces.push({
                        x: [Math.min(...data.Turns.Parallel.Primary), Math.max(...data.Turns.Parallel.Primary)],
                        y: [data.Pmaxp, data.Pmaxp],
                        mode: 'lines',
                        name: 'Pmax_parallel',
                        line: { color: 'red', dash: 'dash', width: 2 }
                    });
                }
                if (!isNaN(data.Optimal.Parallel.Np) && !isNaN(data.Optimal.Parallel.Power)) {
                    traces.push({
                        x: [data.Optimal.Parallel.Np],
                        y: [data.Optimal.Parallel.Power],
                        mode: 'markers',
                        name: `Optimal P (${data.Optimal.Parallel.Np})`,
                        marker: { color: 'purple', size: 10, symbol: 'star' }
                    });
                }
            }

            const layout = {
                title: `Total Power Loss vs. Turns (Combined) for ${selectedCoreName}`,
                xaxis: { title: 'Number of Primary Turns (Np)' },
                yaxis: { title: 'Total Power Loss [W]' },
                hovermode: 'closest'
            };

            Plotly.newPlot(plotDivId, traces, layout);
        }

        function plotKuVsTurns(data, plotDivId) {
            const traces = [];
            const colorMap = colors.map(c => getPlotlyColor(c));
            const selectedCoreName = core_names[data.selectedCoreIndex];

            if (data.Turns.Series.Primary && data.Ku.Series && data.Turns.Series.Primary.length > 0 && data.Ku.Series.length > 0) {
                traces.push({
                    x: data.Turns.Series.Primary,
                    y: data.Ku.Series,
                    mode: 'lines',
                    name: `${selectedCoreName}-S Ku`,
                    line: { color: colorMap[data.selectedCoreIndex % colors.length], width: 2 }
                });
            }

            const layout = {
                title: `Ku vs. Number of Primary Turns (Series) for ${selectedCoreName}`,
                xaxis: { title: 'Number of Primary Turns (Np)' },
                yaxis: { title: 'Ku (Window Utilization Factor)' },
                hovermode: 'closest'
            };

            Plotly.newPlot(plotDivId, traces, layout);
        }

        // Function to populate the core type dropdown
        function populateCoreDropdown() {
            const coreTypeSelect = document.getElementById('coreType');
            core_names.forEach((name, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = name;
                coreTypeSelect.appendChild(option);
            });
        }

        // Function to display the loss difference table
        function displayLossDiffTable(summaryData) {
            const tableContainer = document.getElementById('lossDiffTable');
            let tableHTML = `
                <table class="min-w-full divide-y divide-gray-200">
                    <thead class="bg-gray-50">
                        <tr>
                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Core Name</th>
                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Pmax (Series) [W]</th>
                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Optimal Loss (Series) [W]</th>
                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Optimal Np (Series)</th>
                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Loss Difference (Series) [%]</th>
                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Pmax (Parallel) [W]</th>
                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Optimal Loss (Parallel) [W]</th>
                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Optimal Np (Parallel)</th>
                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Loss Difference (Parallel) [%]</th>
                        </tr>
                    </thead>
                    <tbody class="bg-white divide-y divide-gray-200">
            `;

            summaryData.forEach(data => {
                const lossDiffSeries = !isNaN(data.OptimalSeriesPower) && !isNaN(data.Pmaxs) ? ((data.OptimalSeriesPower - data.Pmaxs) / data.Pmaxs * 100).toFixed(2) : 'N/A';
                const lossDiffParallel = !isNaN(data.OptimalParallelPower) && !isNaN(data.Pmaxp) ? ((data.OptimalParallelPower - data.Pmaxp) / data.Pmaxp * 100).toFixed(2) : 'N/A';

                tableHTML += `
                    <tr>
                        <td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">${data.coreName}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${data.Pmaxs !== null && !isNaN(data.Pmaxs) ? data.Pmaxs.toFixed(2) : 'N/A'}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${data.OptimalSeriesPower !== null && !isNaN(data.OptimalSeriesPower) ? data.OptimalSeriesPower.toFixed(2) : 'N/A'}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${data.OptimalSeriesNp !== null && !isNaN(data.OptimalSeriesNp) ? Math.round(data.OptimalSeriesNp) : 'N/A'}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${lossDiffSeries}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${data.Pmaxp !== null && !isNaN(data.Pmaxp) ? data.Pmaxp.toFixed(2) : 'N/A'}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${data.OptimalParallelPower !== null && !isNaN(data.OptimalParallelPower) ? data.OptimalParallelPower.toFixed(2) : 'N/A'}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${data.OptimalParallelNp !== null && !isNaN(data.OptimalParallelNp) ? Math.round(data.OptimalParallelNp) : 'N/A'}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${lossDiffParallel}</td>
                    </tr>
                `;
            });

            tableHTML += `
                    </tbody>
                </table>
            `;
            tableContainer.innerHTML = tableHTML;
        }

        // Event Listener for the Calculate Button
        document.getElementById('calculateButton').addEventListener('click', () => {
            const loadingOverlay = document.getElementById('loadingOverlay');
            const plotDiv = document.getElementById('plotDiv');
            const plotMessage = plotDiv.querySelector('p'); // Get the message paragraph

            loadingOverlay.classList.remove('hidden'); // Show loading spinner
            if (plotMessage) {
                plotMessage.style.display = 'none'; // Hide the "Select parameters" message
            }

            // Clear previous plot
            Plotly.purge(plotDiv.id);

            // Use a timeout to allow the loading spinner to render before calculations
            setTimeout(() => {
                const { selectedCoreResults, allCoresLossSummary } = calculateLosses();
                const plotType = document.getElementById('plotType').value;

                switch (plotType) {
                    case 'loss_vs_flux':
                        plotLossVsFlux(selectedCoreResults, 'plotDiv');
                        break;
                    case 'loss_vs_turns':
                        plotLossVsTurns(selectedCoreResults, 'plotDiv');
                        break;
                    case 'flux_vs_turns':
                        plotFluxVsTurns(selectedCoreResults, 'plotDiv');
                        break;
                    case 'compare_core':
                        plotCompareCoreLosses(allCoresLossSummary, 'plotDiv');
                        break;
                    case 'layers_vs_turns':
                        plotLayersVsTurns(selectedCoreResults, 'plotDiv');
                        break;
                    case 'skeff_proximity':
                        plotSkeffProximity(selectedCoreResults, 'plotDiv');
                        break;
                    case 'copper_loss_vs_turns':
                        plotCopperLossVsTurns(selectedCoreResults, 'plotDiv');
                        break;
                    case 'total_power_loss_vs_flux_series':
                        plotTotalPowerLossVsFluxSeries(selectedCoreResults, 'plotDiv');
                        break;
                    case 'total_power_loss_vs_flux_parallel':
                        plotTotalPowerLossVsFluxParallel(selectedCoreResults, 'plotDiv');
                        break;
                    case 'total_power_loss_vs_turns_series':
                        plotTotalPowerLossVsTurnsSeries(selectedCoreResults, 'plotDiv');
                        break;
                    case 'total_power_loss_vs_turns_parallel':
                        plotTotalPowerLossVsTurnsParallel(selectedCoreResults, 'plotDiv');
                        break;
                    case 'total_power_loss_vs_turns_combined':
                        plotTotalPowerLossVsTurnsCombined(selectedCoreResults, 'plotDiv');
                        break;
                    case 'ku_vs_turns':
                        plotKuVsTurns(selectedCoreResults, 'plotDiv');
                        break;
                    default:
                        console.warn('Unknown plot type selected:', plotType);
                        plotDiv.innerHTML = '<p class="text-gray-500">No plot available for the selected type.</p>';
                        break;
                }

                displayLossDiffTable(allCoresLossSummary);
                loadingOverlay.classList.add('hidden'); // Hide loading spinner
                if (plotMessage) {
                    plotMessage.style.display = 'block'; // Show the "Select parameters" message again if no plot was rendered
                }
            }, 100); // Small delay to show spinner
        });

        // Initialize core type dropdown on page load
        document.addEventListener('DOMContentLoaded', populateCoreDropdown);
    </script>
</body>
</html>
