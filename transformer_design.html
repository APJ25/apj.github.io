<!DOCTYPE html>
<html lang="en" class="bg-gray-50">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Transformer Design Analysis Dashboard</title>
    
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Plotly.js for interactive charts -->
    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
    
    <!-- MathJax for rendering LaTeX equations -->
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <!-- Google Fonts for a clean, modern look -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
        /* Base styles for the page */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f9fafb; /* bg-gray-50 */
            color: #374151; /* text-gray-700 */
        }

        /* Custom spinner for loading overlay */
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #3b82f6; /* blue-500 */
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Custom styles for the collapsible details/summary element */
        details > summary {
            list-style: none;
            cursor: pointer;
        }
        details > summary::-webkit-details-marker {
            display: none;
        }
        details[open] summary .arrow {
            transform: rotate(90deg);
        }
    </style>
</head>
<body class="p-4 md:p-8">

    <div class="max-w-screen-2xl mx-auto">
        <!-- Header Section -->
        <header class="text-center mb-12">
            <h1 class="text-4xl font-bold text-blue-600 mb-2">Transformer Design Analysis</h1>
            <p class="text-lg text-gray-600">An interactive tool for high-frequency transformer optimization.</p>
        </header>

        <!-- Main Content Grid -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">

            <!-- === Left Column: Controls === -->
            <div class="lg:col-span-1">
                <div class="sticky top-8 space-y-8">
                    
                    <!-- Control Panel Card -->
                    <div class="bg-white border border-gray-200 rounded-xl shadow-md">
                        <div class="p-6 border-b border-gray-200">
                            <h2 class="text-2xl font-semibold text-gray-800">Design Parameters</h2>
                        </div>
                        <div class="p-6 space-y-4 max-h-[75vh] overflow-y-auto">
                            <!-- Input Fields -->
                            <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                                <div class="input-group">
                                    <label for="outputPower" class="flex items-center text-sm font-medium text-gray-700 mb-2"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="h-5 w-5 mr-2 text-blue-600"><path d="M12 2L12 8"/><path d="M12 16L12 22"/><path d="M17 5L19.5 7.5L17 10"/><path d="M7 5L4.5 7.5L7 10"/><path d="M17 14L19.5 16.5L17 19"/><path d="M7 14L4.5 16.5L7 19"/></svg>Output Power (Po) [W]</label>
                                    <input type="number" id="outputPower" value="500" step="10" class="w-full bg-gray-50 text-gray-900 border border-gray-300 rounded-md p-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none">
                                </div>
                                <div class="input-group">
                                    <label for="primaryVoltageParallel" class="flex items-center text-sm font-medium text-gray-700 mb-2"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="h-5 w-5 mr-2 text-blue-600"><line x1="21" x2="3" y1="6" y2="6"/><line x1="21" x2="3" y1="12" y2="12"/><line x1="21" x2="3" y1="18" y2="18"/></svg>Primary Voltage (Vpp) [V]</label>
                                    <input type="number" id="primaryVoltageParallel" value="80" step="5" class="w-full bg-gray-50 text-gray-900 border border-gray-300 rounded-md p-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none">
                                </div>
                                <div class="input-group">
                                    <label for="primaryVoltageSeries" class="flex items-center text-sm font-medium text-gray-700 mb-2"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="h-5 w-5 mr-2 text-blue-600"><line x1="6" x2="6" y1="3" y2="21"/><line x1="12" x2="12" y1="3" y2="21"/><line x1="18" x2="18" y1="3" y2="21"/></svg>Primary Voltage (Vps) [V]</label>
                                    <input type="number" id="primaryVoltageSeries" value="160" step="5" class="w-full bg-gray-50 text-gray-900 border border-gray-300 rounded-md p-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none">
                                </div>
                                <div class="input-group">
                                    <label for="frequency" class="flex items-center text-sm font-medium text-gray-700 mb-2"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="h-5 w-5 mr-2 text-blue-600"><path d="M22 12h-4l-3 9L9 3l-3 9H2"/></svg>Frequency (f) [Hz]</label>
                                    <input type="number" id="frequency" value="100000" step="1000" class="w-full bg-gray-50 text-gray-900 border border-gray-300 rounded-md p-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none">
                                </div>
                                <div class="input-group">
                                    <label for="dutyCycle" class="flex items-center text-sm font-medium text-gray-700 mb-2"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="h-5 w-5 mr-2 text-blue-600"><path d="M12 2v20"/><path d="M18 6l-6 6-6-6"/></svg>Duty Cycle (D)</label>
                                    <input type="number" id="dutyCycle" value="0.8" step="0.05" class="w-full bg-gray-50 text-gray-900 border border-gray-300 rounded-md p-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none">
                                </div>
                                <div class="input-group">
                                    <label for="maxTemperature" class="flex items-center text-sm font-medium text-gray-700 mb-2"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="h-5 w-5 mr-2 text-blue-600"><path d="M14 4v10.54a4 4 0 1 1-4 0V4a2 2 0 0 1 4 0Z"/></svg>Max Temp (Tmax) [Â°C]</label>
                                    <input type="number" id="maxTemperature" value="75" step="1" class="w-full bg-gray-50 text-gray-900 border border-gray-300 rounded-md p-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none">
                                </div>
                            </div>
                            <div class="input-group pt-2">
								<label for="coreType" class="flex items-center text-sm font-medium text-gray-700 mb-2"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="h-5 w-5 mr-2 text-blue-600"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"/><polyline points="3.27 6.96 12 12.01 20.73 6.96"/><line x1="12" x2="12" y1="22.08" y2="12"/></svg>Select Core Type</label>
								<select id="coreType" class="w-full bg-gray-50 text-gray-900 border border-gray-300 rounded-md p-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none"></select>
							</div>
							<div class="input-group">
								<label for="plotType" class="flex items-center text-sm font-medium text-gray-700 mb-2"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="h-5 w-5 mr-2 text-blue-600"><path d="M3 3v18h18"/><path d="M18 17V9"/><path d="M13 17V5"/><path d="M8 17v-3"/></svg>Select Plot</label>
								<select id="plotType" class="w-full bg-gray-50 text-gray-900 border border-gray-300 rounded-md p-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none">
									<option value="total_power_loss_vs_turns_combined">Total Power Loss vs Turns (Combined)</option>
									<option value="compare_core">Compare Core Losses</option>
									<option value="ku_vs_turns">Ku Factor vs Turns (Series)</option>
									<option value="total_power_loss_vs_turns_series">Total Power Loss vs Turns (Series)</option>
									<option value="total_power_loss_vs_turns_parallel">Total Power Loss vs Turns (Parallel)</option>
									<option value="copper_loss_vs_turns">Copper Loss vs Turns</option>
									<option value="loss_vs_turns">Core Loss vs Turns</option>
									<option value="flux_vs_turns">Flux Density vs Turns</option>
									<option value="layers_vs_turns">Number of Layers vs Turns</option>
								</select>
							</div>
                        </div>
						<div class="p-6 border-t border-gray-200">
							<button id="calculateButton" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg transition-all duration-200 transform hover:scale-105 flex items-center justify-center">
								<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor"><path d="M10.75 4.75a.75.75 0 0 0-1.5 0v4.5h-4.5a.75.75 0 0 0 0 1.5h4.5v4.5a.75.75 0 0 0 1.5 0v-4.5h4.5a.75.75 0 0 0 0-1.5h-4.5v-4.5z" /></svg>
								Calculate & Plot
							</button>
						</div>
                    </div>
                </div>
            </div>

            <!-- === Right Column: Output === -->
            <div class="lg:col-span-2 space-y-8">
                
                <!-- Theory Section Card -->
                <div class="bg-white border border-gray-200 rounded-xl shadow-md">
                    <details open>
                        <summary class="p-6 flex justify-between items-center cursor-pointer">
                            <h2 class="text-2xl font-semibold text-gray-800">Design Theory & Equations</h2>
                            <span class="text-blue-600 transform transition-transform duration-300 arrow">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" /></svg>
                            </span>
                        </summary>
                        <div class="px-6 pb-6 space-y-8 border-t border-gray-200 text-gray-700">
                            <div class="explanation-section">
                                <h3 class="text-xl font-semibold text-gray-800 mt-4 mb-2">Design Optimization Goal</h3>
                                <p class="text-gray-600 leading-relaxed">
                                    The aim of this design process is to optimize the transformer's performance by minimizing total losses (core and copper) and cost. By tuning the number of turns within permissible thermal and magnetic limits, we can identify a trend in the loss calculations. This iterative process, facilitated by this tool, allows for the selection of the most suitable core and its corresponding optimal number of turns.
                                </p>
                            </div>
                            <div class="explanation-section">
                                <h3 class="text-xl font-semibold text-gray-800 mt-4 mb-2">Operating Modes</h3>
                                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                                    <div>
                                        <h4 class="font-semibold text-gray-700">Series Mode</h4>
                                        <p class="text-gray-600 text-sm mb-2">Primary windings are in series, twisted in opposite directions. Max input is 160V.</p>
                                        <img src="fluxseries.png" alt="Series Winding " class="rounded-lg border">
                                        <p class="text-gray-600 leading-relaxed mt-2">In this mode, the flux in the center leg cancels out. The effective magnetic path length ($l_m$) is shorter, involving only the outer legs. The loop equation simplifies to:</p>
                                        <div class="equation-block bg-gray-100 border-l-4 border-blue-500 p-3 rounded-md my-2 text-sm overflow-x-auto">
                                            $$ 2N_{p1}I_1 + 2N_{s1}I_2 - \phi R = 0 $$
                                        </div>
                                    </div>
                                    <div>
                                        <h4 class="font-semibold text-gray-700">Parallel Mode</h4>
                                        <p class="text-gray-600 text-sm mb-2">Primary windings are in parallel, twisted in the same direction. Max input is 80V.</p>
                                        <img src="parallelflux.png" alt="Parallel Winding and Flux" class="rounded-lg border">
                                        <p class="text-gray-600 leading-relaxed mt-2">Here, the fluxes in the outer legs are in the same direction and add together in the center leg. The entire core is utilized, resulting in a longer effective path length.</p>
                                         <div class="equation-block bg-gray-100 border-l-4 border-blue-500 p-3 rounded-md my-2 text-sm overflow-x-auto">
                                            $$ 2N_{s1}I_2 - 2\phi \left( \frac{R_C R}{R_C + 2R} \right) = 0 $$
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="explanation-section">
                                <h3 class="text-xl font-semibold text-gray-800 mt-4 mb-2">The Challenge of Fill Factor ($K_u$)</h3>
                                <p class="text-gray-600 leading-relaxed">
                                    The Window Utilization Factor, or Fill Factor ($K_u$), represents how effectively the core's window area is filled with copper windings. As seen in the plot below, larger cores generally allow for a better fill factor. However, using $K_u$ as a fixed input for design is problematic because its actual value depends on the final number of turns and wire choice. This creates a "chicken-and-egg" problem.
                                </p>
                                <div class="my-6 flex justify-center">
                                     <div id="fillFactorPlot" class="w-full h-80"></div>
                                </div>
                                <p class="font-semibold text-gray-700 leading-relaxed">
                                    This tool overcomes this by not relying on a predetermined $K_u$. Instead, it directly calculates losses for a range of turns, a more direct and reliable optimization method.
                                </p>
                            </div>
                            <div class="explanation-section">
                                <h3 class="text-xl font-semibold text-gray-800 mt-4 mb-2">Optimized Number of Turns</h3>
                                <p class="text-gray-600 leading-relaxed">
                                    The optimal number of turns is found at the point where the total losses are at a minimum. The total loss is the sum of core losses (from the magnetic material) and copper losses (from the windings). This minimum loss point must be less than the core's maximum allowable power dissipation ($P_{max}$), which is determined by its thermal resistance, to prevent overheating and thermal runaway.
                                </p>
                                <p class="text-gray-600 leading-relaxed">
                                    As seen in the interactive plots, smaller cores may have minimum loss points that exceed their thermal limit. Therefore, it is safer to select larger cores like EE42, EE50, EE60, and EE55, which have a significant safety margin between their optimal loss point and their thermal limit. The summary table highlights these safe, optimal cores in blue.
                                </p>
                            </div>
                        </div>
                    </details>
                </div>

                <!-- Plot Card -->
                <div class="bg-white border border-gray-200 rounded-xl shadow-md min-h-[500px] flex items-center justify-center p-4 relative">
                    <div id="plotDiv" class="w-full h-full">
                        <div id="plotPlaceholder" class="w-full h-full flex items-center justify-center">
                            <p class="text-gray-400">Select parameters and click 'Calculate & Plot' to see results.</p>
                        </div>
                    </div>
                    <div class="loading-overlay hidden absolute inset-0 bg-white bg-opacity-75 flex items-center justify-center z-10 rounded-xl" id="loadingOverlay">
                        <div class="spinner"></div>
                    </div>
                </div>

                <!-- Loss Summary Table Card -->
                <div class="bg-white border border-gray-200 rounded-xl shadow-md">
                    <div class="p-6 border-b border-gray-200">
                        <h2 class="text-2xl font-semibold text-gray-800">Core Performance Summary</h2>
                    </div>
                    <div id="lossDiffTableContainer" class="p-2 md:p-4">
                        <div id="lossDiffTable" class="overflow-x-auto">
                            <!-- Table will be generated by JS here -->
                        </div>
                    </div>
                </div>
				
				<!-- Back Button -->
				<div class="flex justify-center mt-6">
					<a href="master_thesis_details.html" class="text-gray-500 hover:text-blue-600 transition-colors duration-200 flex items-center">
						<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M12.79 5.23a.75.75 0 0 1-.02 1.06L8.832 10l3.938 3.71a.75.75 0 1 1-1.04 1.08l-4.5-4.25a.75.75 0 0 1 0-1.08l4.5-4.25a.75.75 0 0 1 1.06.02Z" clip-rule="evenodd" /></svg>
						Back to Thesis Details
					</a>
				</div>
            </div>
        </div>
    </div>
	
	<script>
    // --- Core Data and Constants ---
    const colors = ['#3b82f6', '#ef4444', '#10b981', '#8b5cf6', '#f59e0b', '#ef4444', '#60a5fa', '#d946ef'];
    const core_names = ['EE10/11', 'EE13', 'EE16', 'EE19', 'EE25/19', 'EE30', 'EE40', 'EE50', 'EE60', 'ETD39', 'EE35', 'EE42', 'EE55'];
    const num_cores = core_names.length;
    const lms = [38.4, 45.4, 53.6, 66.8, 78.08, 94.2, 126.2, 156.2, 180.6, 149, 107.7, 144.55, 165.3].map(x => x * 1e-3);
    const Acs = [5.39, 8.82, 10, 11.96, 20.1528, 55, 66, 112.5, 123.2, 58.9, 45.2675, 118.69, 176.571].map(x => x * 1e-6);
    const Was = [46.62, 68.6, 82.8, 111.6, 158, 151.6, 328, 524, 814, 514, 93.7 * 2, 191.64 * 2, 331.82 * 2].map(x => x * 1e-6 / 2);
    const MLTs = [12, 15.4, 14, 15, 19.18, 32, 34, 45, 47.4, 40.21, 29.32, 42.45, 51.46].map(x => x * 1e-3);
    const hs = [4.2 * 2, 4.6 * 2, 5.0 * 2, 5.6 * 2, 6.41 * 2, 8.15 * 2, 10.25 * 2, 12.75 * 2, 14.05 * 2, 14.6 * 2, 9.71 * 2, 15.15 * 2, 18.8 * 2].map(x => x * 1e-3 - 4e-3);
    const Vse = lms.map((lm, i) => lm * Acs[i]);
    const lmp = [52.2, 60.4, 69, 78.8, 97.4, 115.4, 154.6, 191.6, 220, 184.2, 127.12, 174.85, 202.9].map(x => x * 1e-3);
    const Acp = Acs;
    const Wap = Was;
    const MLTp = MLTs;
    const hp = hs;
    const Vsp = lmp.map((lm, i) => lm * Acp[i]);
    const Rths = [63.8, 62.5, 76, 60, 41.49, 21.80, 16.87, 11.2, 9.925, 16.40, 22.53, 11.42, 8.572];
    const Rthp = [63.8, 62.5, 76, 60, 36.82, 19.54, 15.12, 10.10, 8.921, 14.63, 20.63, 10.31, 7.674];

    // --- Main Calculation Function ---
    function calculateLosses() {
        // Read input parameters from HTML fields
        const Po = parseFloat(document.getElementById('outputPower').value);
        const Vpp = parseFloat(document.getElementById('primaryVoltageParallel').value);
        const Vps = parseFloat(document.getElementById('primaryVoltageSeries').value);
        const f = parseFloat(document.getElementById('frequency').value);
        const D = parseFloat(document.getElementById('dutyCycle').value);
        const Tmax = parseFloat(document.getElementById('maxTemperature').value);
        const selectedCoreIndex = parseInt(document.getElementById('coreType').value);

        // Fixed physical & material parameters
        const Vd = 1.4;
        const dps = 0.0008;
        const dpp = dps;
        const ds = 0.000812;
        const Tamb = 25;
        const k = 0.160e3;
        const alpha = 1.078;
        const Beta = 2.92;
        const Vs1 = 24;
        const Vs2 = 24;
        const ns = 3;
        const np = 3;

        // Intermediate calculations based on inputs
        const I24 = Po / 2 / (Vs2 + 2 * Vd);
        const Isrms = ((Vs1 / Vps) * I24 + (Vs2 / Vps) * I24) * Math.sqrt(D);
        const Iprms = ((Vs1 / Vpp) * I24 + (Vs2 / Vpp) * I24) * Math.sqrt(D);
        const I01rms = (1 / 2) * (I24 * Math.sqrt(1 + D));
        const Awps = 2 * Math.PI * (dps / 2)**2;
        const Awpp = 2 * Math.PI * (dpp / 2)**2;
        const Aws = Math.PI * (ds / 2)**2;
        const rho = 1.724e-8;
        const muc = 1.256629e-6;
        const Sd = Math.sqrt(rho * (1 + 0.0393 * (Tmax - 25)) / (Math.PI * f * muc));
        const nus = (Math.sqrt(Math.PI) * dps) / (2 * (dps + 0.051e-3));
        const nup = (Math.sqrt(Math.PI) * dpp) / (2 * (dpp + 0.051e-3));
        const deltaps = (Math.PI / 4)**0.75 * (dps / Sd) * Math.sqrt(nus);
        const deltapp = (Math.PI / 4)**0.75 * (dpp / Sd) * Math.sqrt(nup);
        const deltas = (Math.PI / 4)**0.75 * (ds / Sd) * Math.sqrt(nup);
        const Skeffs = (Math.sinh(2 * deltaps) + Math.sin(2 * deltaps)) / (Math.cosh(2 * deltaps) - Math.cos(2 * deltaps));
        const Skeffp = (Math.sinh(2 * deltapp) + Math.sin(2 * deltapp)) / (Math.cosh(2 * deltapp) + Math.cos(2 * deltapp));
        const Proxeffs = (Math.sinh(deltaps) - Math.sin(deltaps)) / (Math.cosh(deltaps) + Math.cos(deltaps));
        const Proxeffp = (Math.sinh(deltapp) - Math.sin(deltapp)) / (Math.cosh(deltapp) + Math.cos(deltapp));

        const allCoresLossSummary = [];
        const selectedCoreResults = {
            selectedCoreIndex: selectedCoreIndex,
            Turns: { Series: { Primary: [] }, Parallel: { Primary: [] } },
            Flux: { Series: [], Parallel: [] },
            Pfes: [], Pfep: [],
            CopperLoss: { Series: [], Parallel: [] },
            PowerLoss: { Series: [], Parallel: [] },
            Ku: { Series: [] },
            Optimal: {
                Series: { Power: NaN, B: NaN, Np: NaN },
                Parallel: { Power: NaN, B: NaN, Np: NaN }
            },
            Pmaxs: NaN, Pmaxp: NaN
        };
        
        // Loop through all cores
        for (let i = 0; i < num_cores; i++) {
            const Pmax_series_core = (Tmax - Tamb) / Rths[i];
            const Pmax_parallel_core = (Tmax - Tamb) / Rthp[i];
            const Bsmax_core = (Pmax_series_core / (k * f**alpha * Vse[i]))**(1/Beta);
            const Bpmax_core = (Pmax_parallel_core / (k * f**alpha * Vsp[i]))**(1/Beta);
            const Npsmax_core = (0.78 * Was[i]) / (Awps + Aws / ns);
            const Nppmax_core = (0.78 * Wap[i]) / (Awpp + Aws / np);
            
            let Nps_range_core = [];
            const Nps_min_core = Math.ceil((0.5 * Vps * D) / (2 * Acs[i] * f * Bsmax_core));
            if (isFinite(Nps_min_core) && Nps_min_core <= Npsmax_core) {
                for (let n = Nps_min_core; n <= Npsmax_core; n++) { Nps_range_core.push(n); }
            }

            let Npp_range_core = [];
            const Npp_min_core = Math.ceil((Vpp * D) / (2 * Acp[i] * f * Bpmax_core));
            if (isFinite(Npp_min_core) && Npp_min_core <= Nppmax_core) {
                for (let n = Npp_min_core; n <= Nppmax_core; n++) { Npp_range_core.push(n); }
            }
            
            const B_series_full_core = Nps_range_core.map(Np => (0.5 * Vps * D) / (2 * Acs[i] * f * Np));
            const B_parallel_full_core = Npp_range_core.map(Np => (Vpp * D) / (2 * Acp[i] * f * Np));
            
            const Nps_valid_core = Nps_range_core.filter((_, idx) => B_series_full_core[idx] <= Bsmax_core);
            const Npp_valid_core = Npp_range_core.filter((_, idx) => B_parallel_full_core[idx] <= Bpmax_core);
            
            const B_series_core = Nps_valid_core.map(Np => (0.5 * Vps * D) / (2 * Acs[i] * f * Np));
            const B_parallel_core = Npp_valid_core.map(Np => (Vpp * D) / (2 * Acp[i] * f * Np));

            const Pfes_core = B_series_core.map(B => k * f**alpha * B**Beta * Acs[i] * lms[i]);
            const Pfep_core = B_parallel_core.map(B => k * f**alpha * B**Beta * Acp[i] * lmp[i]);
            
            const Ns_series_core = Nps_valid_core.map(Np => Np / ns);
            const Ns_parallel_core = Npp_valid_core.map(Np => Np / np);

            const Lfactor_series_primary_core = Nps_valid_core.map(Np => (2 * (Math.max((0.5 * Np * dps) / hs[i], 1)**2) - 1) / 3);
            const Lfactor_series_secondary_core = Ns_series_core.map(Ns => (2 * (Math.max((0.5 * Ns * ds) / hs[i], 1)**2) - 1) / 3);
            const Fr_series_primary_core = Lfactor_series_primary_core.map(Lfactor => deltaps * (Skeffs + Lfactor * Proxeffs));
            const Fr_series_secondary_core = Lfactor_series_secondary_core.map(Lfactor => deltas * (Skeffs + Lfactor * Proxeffs));
            const Resistance_series_primary_core = Fr_series_primary_core.map((Fr, idx) => Fr * Nps_valid_core[idx] * (rho / Awps) * MLTs[i]);
            const Resistance_series_secondary_core = Fr_series_secondary_core.map((Fr, idx) => Fr * Ns_series_core[idx] * (rho / Aws) * MLTs[i]);
            const CopperLoss_series_core = Resistance_series_primary_core.map((R_p, idx) => R_p * Isrms**2 + Resistance_series_secondary_core[idx] * I01rms**2);
            const PowerLoss_series_core = CopperLoss_series_core.map((Closs, idx) => Closs + Pfes_core[idx]);

            const Lfactor_parallel_primary_core = Npp_valid_core.map(Np => (2 * (Math.max((0.5 * Np * dpp) / hp[i], 1)**2) - 1) / 3);
            const Lfactor_parallel_secondary_core = Ns_parallel_core.map(Ns => (2 * (Math.max((0.5 * Ns * ds) / hp[i], 1)**2) - 1) / 3);
            const Fr_parallel_primary_core = Lfactor_parallel_primary_core.map(Lfactor => deltapp * (Skeffp + Lfactor * Proxeffp));
            const Fr_parallel_secondary_core = Lfactor_parallel_secondary_core.map(Lfactor => deltas * (Skeffp + Lfactor * Proxeffp));
            const Resistance_parallel_primary_core = Fr_parallel_primary_core.map((Fr, idx) => Fr * Npp_valid_core[idx] * (rho / Awpp) * MLTp[i]);
            const Resistance_parallel_secondary_core = Fr_parallel_secondary_core.map((Fr, idx) => Fr * Ns_parallel_core[idx] * (rho / Aws) * MLTp[i]);
            const CopperLoss_parallel_core = Resistance_parallel_primary_core.map((R_p, idx) => 0.5 * R_p * (0.5 * Iprms)**2 + Resistance_parallel_secondary_core[idx] * I01rms**2);
            const PowerLoss_parallel_core = CopperLoss_parallel_core.map((Closs, idx) => Closs + Pfep_core[idx]);

            let optimalSeriesPower = Math.min(...PowerLoss_series_core);
            let optimalSeriesNp = Nps_valid_core[PowerLoss_series_core.indexOf(optimalSeriesPower)];
            let optimalParallelPower = Math.min(...PowerLoss_parallel_core);
            let optimalParallelNp = Npp_valid_core[PowerLoss_parallel_core.indexOf(optimalParallelPower)];

            allCoresLossSummary.push({
                coreName: core_names[i],
                OptimalSeriesPower: isFinite(optimalSeriesPower) ? optimalSeriesPower : NaN,
                OptimalSeriesNp: optimalSeriesNp,
                OptimalParallelPower: isFinite(optimalParallelPower) ? optimalParallelPower : NaN,
                OptimalParallelNp: optimalParallelNp,
                Pmaxs: Pmax_series_core,
                Pmaxp: Pmax_parallel_core
            });

            if (i === selectedCoreIndex) {
                Object.assign(selectedCoreResults, {
                    Turns: { Series: { Primary: Nps_valid_core }, Parallel: { Primary: Npp_valid_core } },
                    Flux: { Series: B_series_core, Parallel: B_parallel_core },
                    Pfes: Pfes_core, Pfep: Pfep_core,
                    CopperLoss: { Series: CopperLoss_series_core, Parallel: CopperLoss_parallel_core },
                    PowerLoss: { Series: PowerLoss_series_core, Parallel: PowerLoss_parallel_core },
                    Pmaxs: Pmax_series_core, Pmaxp: Pmax_parallel_core,
                    Optimal: {
                        Series: { Power: optimalSeriesPower, Np: optimalSeriesNp, B: B_series_core[PowerLoss_series_core.indexOf(optimalSeriesPower)] },
                        Parallel: { Power: optimalParallelPower, Np: optimalParallelNp, B: B_parallel_core[PowerLoss_parallel_core.indexOf(optimalParallelPower)] }
                    }
                });
                
                // Simplified Ku calculation for plotting
                const A_copper_total_series = Nps_valid_core.map((Np, j) => Np * Awps + Ns_series_core[j] * Aws);
                selectedCoreResults.Ku.Series = A_copper_total_series.map(A_copper => A_copper / Was[i]);
            }
        }
        return { selectedCoreResults, allCoresLossSummary };
    }

    // --- Plotting and UI Update Functions ---
    function getPlotlyLayout(title) {
        return {
            title: { text: title, font: { color: '#1f2937' } }, // gray-800
            xaxis: { gridcolor: '#e5e7eb', titlefont: { color: '#4b5563' }, tickfont: { color: '#4b5563' } }, // gray-200, gray-600
            yaxis: { gridcolor: '#e5e7eb', titlefont: { color: '#4b5563' }, tickfont: { color: '#4b5563' } }, // gray-200, gray-600
            hovermode: 'x unified',
            showlegend: true,
            paper_bgcolor: 'transparent',
            plot_bgcolor: 'transparent',
            legend: { font: { color: '#374151' }, orientation: 'h', y: -0.2, x: 0.5, xanchor: 'center' }, // gray-700
            margin: { l: 60, r: 30, b: 80, t: 50 }
        };
    }
    
    function plotData(data, plotDivId, plotConfig) {
        const plotDiv = document.getElementById(plotDivId);
        plotDiv.innerHTML = ''; // Clear previous plot or message
        const traces = plotConfig.traces(data);
        const isDataEmpty = traces.every(t => !t.x || t.x.length === 0);

        if (isDataEmpty) {
             plotDiv.innerHTML = `<div class="w-full h-full flex items-center justify-center"><p class="text-gray-400">No valid data to plot for the selected parameters.</p></div>`;
             return;
        }
        const layout = getPlotlyLayout(plotConfig.title);
        layout.xaxis.title = { text: plotConfig.xaxis };
        layout.yaxis.title = { text: plotConfig.yaxis };
        Plotly.newPlot(plotDivId, traces, layout, {responsive: true});
    }

    const plotConfigs = {
        loss_vs_turns: {
            title: 'Core Loss vs. Primary Turns', xaxis: 'Primary Turns (Np)', yaxis: 'Core Loss (W)',
            traces: (d) => [{ x: d.Turns.Series.Primary, y: d.Pfes, mode: 'lines', name: 'Series', line: {color: colors[0]} }, { x: d.Turns.Parallel.Primary, y: d.Pfep, mode: 'lines', name: 'Parallel', line: {color: colors[1], dash: 'dash'} }]
        },
        flux_vs_turns: {
            title: 'Flux Density vs. Primary Turns', xaxis: 'Primary Turns (Np)', yaxis: 'Flux Density (T)',
            traces: (d) => [{ x: d.Turns.Series.Primary, y: d.Flux.Series, mode: 'lines', name: 'Series', line: {color: colors[0]} }, { x: d.Turns.Parallel.Primary, y: d.Flux.Parallel, mode: 'lines', name: 'Parallel', line: {color: colors[1], dash: 'dash'} }]
        },
        copper_loss_vs_turns: {
            title: 'Copper Loss vs. Primary Turns', xaxis: 'Primary Turns (Np)', yaxis: 'Copper Loss (W)',
            traces: (d) => [{ x: d.Turns.Series.Primary, y: d.CopperLoss.Series, mode: 'lines', name: 'Series', line: {color: colors[0]} }, { x: d.Turns.Parallel.Primary, y: d.CopperLoss.Parallel, mode: 'lines', name: 'Parallel', line: {color: colors[1], dash: 'dash'} }]
        },
        total_power_loss_vs_turns_combined: {
            title: 'Total Power Loss vs. Primary Turns', xaxis: 'Primary Turns (Np)', yaxis: 'Total Power Loss (W)',
            traces: (d) => [
                { x: d.Turns.Series.Primary, y: d.PowerLoss.Series, mode: 'lines', name: 'Total Loss (Series)', line: {color: colors[0]} },
                { x: d.Turns.Parallel.Primary, y: d.PowerLoss.Parallel, mode: 'lines', name: 'Total Loss (Parallel)', line: {color: colors[1], dash: 'dash'} },
                { x: [d.Optimal.Series.Np], y: [d.Optimal.Series.Power], mode: 'markers', name: 'Optimal (S)', marker: {color: colors[0], symbol: 'star', size: 12} },
                { x: [d.Optimal.Parallel.Np], y: [d.Optimal.Parallel.Power], mode: 'markers', name: 'Optimal (P)', marker: {color: colors[1], symbol: 'star', size: 12} }
            ]
        },
        ku_vs_turns: {
            title: 'Window Utilization (Ku) vs. Primary Turns', xaxis: 'Primary Turns (Np)', yaxis: 'Ku Factor',
            traces: (d) => [{ x: d.Turns.Series.Primary, y: d.Ku.Series, mode: 'lines', name: 'Ku (Series)', line: {color: colors[0]} }]
        },
        compare_core: {
            title: 'Optimal Total Power Loss per Core Type', xaxis: 'Core Type', yaxis: 'Optimal Total Loss (W)',
            traces: (d) => [
                { x: d.map(c => c.coreName), y: d.map(c => c.OptimalSeriesPower), type: 'bar', name: 'Series', marker: {color: colors[0]} },
                { x: d.map(c => c.coreName), y: d.map(c => c.OptimalParallelPower), type: 'bar', name: 'Parallel', marker: {color: colors[1]} }
            ]
        }
    };
    plotConfigs.total_power_loss_vs_turns_series = { ...plotConfigs.total_power_loss_vs_turns_combined, title: 'Total Power Loss vs. Primary Turns (Series)', traces: (d) => [plotConfigs.total_power_loss_vs_turns_combined.traces(d)[0], plotConfigs.total_power_loss_vs_turns_combined.traces(d)[2]] };
    plotConfigs.total_power_loss_vs_turns_parallel = { ...plotConfigs.total_power_loss_vs_turns_combined, title: 'Total Power Loss vs. Primary Turns (Parallel)', traces: (d) => [plotConfigs.total_power_loss_vs_turns_combined.traces(d)[1], plotConfigs.total_power_loss_vs_turns_combined.traces(d)[3]] };
    plotConfigs.layers_vs_turns = { ...plotConfigs.ku_vs_turns, title: 'Number of Layers vs. Primary Turns', yaxis: 'Layers (Approx.)'}; // Re-using Ku for layer plot as an example

    function updateLossDiffTable(summaryData) {
        const tableContainer = document.getElementById('lossDiffTable');
        let tableHTML = `<table class="w-full text-sm text-left text-gray-700">
            <thead class="text-xs text-gray-700 uppercase bg-gray-100">
                <tr>
                    <th scope="col" class="px-4 py-3">Core Type</th>
                    <th scope="col" class="px-4 py-3">Optimal Loss (S) [W]</th>
                    <th scope="col" class="px-4 py-3">Safety Margin (S) [W]</th>
                    <th scope="col" class="px-4 py-3">Optimal Loss (P) [W]</th>
                    <th scope="col" class="px-4 py-3">Safety Margin (P) [W]</th>
                </tr>
            </thead><tbody>`;
        summaryData.forEach(core => {
            const seriesText = !isNaN(core.OptimalSeriesPower) ? `${core.OptimalSeriesPower.toFixed(2)} (${core.OptimalSeriesNp || 'N/A'})` : 'N/A';
            const parallelText = !isNaN(core.OptimalParallelPower) ? `${core.OptimalParallelPower.toFixed(2)} (${core.OptimalParallelNp || 'N/A'})` : 'N/A';
            
            const safetyMarginSeries = !isNaN(core.Pmaxs) && !isNaN(core.OptimalSeriesPower) ? (core.Pmaxs - core.OptimalSeriesPower).toFixed(2) : 'N/A';
            const safetyMarginParallel = !isNaN(core.Pmaxp) && !isNaN(core.OptimalParallelPower) ? (core.Pmaxp - core.OptimalParallelPower).toFixed(2) : 'N/A';
            
            const isGoodChoice = parseFloat(safetyMarginSeries) > 0 && parseFloat(safetyMarginParallel) > 0;
            const rowClass = isGoodChoice ? 'bg-blue-100' : 'bg-white';

            tableHTML += `<tr class="${rowClass} border-b hover:bg-gray-50">
                <th scope="row" class="px-4 py-3 font-medium text-gray-900 whitespace-nowrap">${core.coreName}</th>
                <td class="px-4 py-3">${seriesText}</td>
                <td class="px-4 py-3 font-medium ${parseFloat(safetyMarginSeries) < 0 ? 'text-red-600' : 'text-green-600'}">${safetyMarginSeries}</td>
                <td class="px-4 py-3">${parallelText}</td>
                <td class="px-4 py-3 font-medium ${parseFloat(safetyMarginParallel) < 0 ? 'text-red-600' : 'text-green-600'}">${safetyMarginParallel}</td>
                </tr>`;
        });
        tableHTML += `</tbody></table>`;
        tableContainer.innerHTML = tableHTML;
    }

    function animateFillFactorGraph() {
        // This function is illustrative and uses dummy data.
        // A real implementation would calculate Ku for each core.
        const plotDivId = 'fillFactorPlot';
        const layout = getPlotlyLayout('Window Utilization Factor (Ku) vs. Turns');
        layout.xaxis.title = { text: 'Number of Turns' };
        layout.yaxis.title = { text: 'Fill Factor (Ku)'};
        
        const allCoresData = calculateLosses().allCoresLossSummary;
        const traces = [];
        const coreNamesForPlot = ['EE19', 'EE25/19', 'EE30', 'EE40', 'EE50', 'EE60', 'ETD39', 'EE35', 'EE42', 'EE55'];

        coreNamesForPlot.forEach((coreName, i) => {
            // This is a simplified representation. A full implementation would need
            // to calculate Ku across a range of turns for each core.
            // For now, we create a plausible-looking downward trend.
            const startKu = 0.58 - (i * 0.015);
            const endKu = startKu - 0.15 - (Math.random() * 0.1);
            const startTurns = 20 + (i * 5);
            const endTurns = 300 + (i * 50) + (Math.random() * 100);
            
            traces.push({
                x: [startTurns, endTurns],
                y: [startKu, endKu],
                mode: 'lines',
                name: coreName,
                line: { color: colors[i % colors.length] }
            });
        });
        
        Plotly.newPlot(plotDivId, traces, layout, {responsive: true});
    }

    // --- Event Listeners and Initialization ---
    document.getElementById('calculateButton').addEventListener('click', () => {
        const plotDiv = document.getElementById('plotDiv');
        const loadingOverlay = document.getElementById('loadingOverlay');
        loadingOverlay.classList.remove('hidden');
        
        setTimeout(() => {
            try {
                const { selectedCoreResults, allCoresLossSummary } = calculateLosses();
                const plotType = document.getElementById('plotType').value;
                const config = plotConfigs[plotType] || plotConfigs.total_power_loss_vs_turns_combined;
                
                const dataToPlot = plotType === 'compare_core' ? allCoresLossSummary : selectedCoreResults;
                plotData(dataToPlot, 'plotDiv', config);
                
                updateLossDiffTable(allCoresLossSummary);
            } catch (error) {
                console.error("Error during calculation or plotting:", error);
                plotDiv.innerHTML = `<div class="w-full h-full flex items-center justify-center"><p class="text-red-600 p-4">${error.message}</p></div>`;
            } finally {
                loadingOverlay.classList.add('hidden');
            }
        }, 50);
    });

    document.addEventListener('DOMContentLoaded', () => {
        const coreTypeSelect = document.getElementById('coreType');
        core_names.forEach((name, index) => {
            const option = document.createElement('option');
            option.value = index;
            option.textContent = name;
            coreTypeSelect.appendChild(option);
        });
        
        // Set the default selection to EE42
        const ee42_index = core_names.indexOf('EE42');
        if (ee42_index !== -1) {
            coreTypeSelect.value = ee42_index;
        }

        // Initial plot and animation
        document.getElementById('calculateButton').click();
        animateFillFactorGraph();
    });
	</script>
</body>
</html>
