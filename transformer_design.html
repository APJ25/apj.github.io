<!DOCTYPE html>
<html lang="en" class="bg-gray-50">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Transformer Design Analysis Dashboard</title>
    
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Plotly.js for interactive charts -->
    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
    
    <!-- MathJax for rendering LaTeX equations -->
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <!-- Google Fonts for a clean, modern look -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
        /* Base styles for the page */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f9fafb; /* bg-gray-50 */
            color: #374151; /* text-gray-700 */
        }

        /* Custom spinner for loading overlay */
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #3b82f6; /* blue-500 */
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Custom styles for the collapsible details/summary element */
        details > summary {
            list-style: none;
            cursor: pointer;
        }
        details > summary::-webkit-details-marker {
            display: none;
        }
        details[open] summary .arrow {
            transform: rotate(90deg);
        }
        .animated-graph {
            transition: transform 0.3s ease-in-out, box-shadow 0.3s ease-in-out;
        }
        .animated-graph:hover {
            transform: scale(1.02);
            box-shadow: 0 10px 20px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body class="p-4 md:p-8">

    <div class="max-w-screen-2xl mx-auto">
        <!-- Header Section -->
        <header class="text-center mb-12">
            <h1 class="text-4xl font-bold text-blue-600 mb-2">Transformer Design Analysis</h1>
            <p class="text-lg text-gray-600">An interactive tool for high-frequency transformer optimization.</p>
        </header>

        <!-- Main Content Grid -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">

            <!-- === Left Column: Controls === -->
            <div class="lg:col-span-1">
                <div class="sticky top-8 space-y-8">
                    
                    <!-- Control Panel Card -->
                    <div class="bg-white border border-gray-200 rounded-xl shadow-md">
                        <div class="p-6 border-b border-gray-200">
                            <h2 class="text-2xl font-semibold text-gray-800">Design Parameters</h2>
                        </div>
                        <div class="p-6 space-y-4 max-h-[75vh] overflow-y-auto">
                            <!-- Input Fields -->
                            <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                                <div class="input-group">
                                    <label for="outputPower" class="flex items-center text-sm font-medium text-gray-700 mb-2"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="h-5 w-5 mr-2 text-blue-600"><path d="M12 2L12 8"/><path d="M12 16L12 22"/><path d="M17 5L19.5 7.5L17 10"/><path d="M7 5L4.5 7.5L7 10"/><path d="M17 14L19.5 16.5L17 19"/><path d="M7 14L4.5 16.5L7 19"/></svg>Output Power (Po) [W]</label>
                                    <input type="number" id="outputPower" value="500" step="10" class="w-full bg-gray-50 text-gray-900 border border-gray-300 rounded-md p-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none">
                                </div>
                                <div class="input-group">
                                    <label for="primaryVoltageParallel" class="flex items-center text-sm font-medium text-gray-700 mb-2"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="h-5 w-5 mr-2 text-blue-600"><line x1="21" x2="3" y1="6" y2="6"/><line x1="21" x2="3" y1="12" y2="12"/><line x1="21" x2="3" y1="18" y2="18"/></svg>Primary Voltage (Vpp) [V]</label>
                                    <input type="number" id="primaryVoltageParallel" value="80" step="5" class="w-full bg-gray-50 text-gray-900 border border-gray-300 rounded-md p-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none">
                                </div>
                                <div class="input-group">
                                    <label for="primaryVoltageSeries" class="flex items-center text-sm font-medium text-gray-700 mb-2"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="h-5 w-5 mr-2 text-blue-600"><line x1="6" x2="6" y1="3" y2="21"/><line x1="12" x2="12" y1="3" y2="21"/><line x1="18" x2="18" y1="3" y2="21"/></svg>Primary Voltage (Vps) [V]</label>
                                    <input type="number" id="primaryVoltageSeries" value="160" step="5" class="w-full bg-gray-50 text-gray-900 border border-gray-300 rounded-md p-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none">
                                </div>
                                <div class="input-group">
                                    <label for="frequency" class="flex items-center text-sm font-medium text-gray-700 mb-2"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="h-5 w-5 mr-2 text-blue-600"><path d="M22 12h-4l-3 9L9 3l-3 9H2"/></svg>Frequency (f) [Hz]</label>
                                    <input type="number" id="frequency" value="100000" step="1000" class="w-full bg-gray-50 text-gray-900 border border-gray-300 rounded-md p-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none">
                                </div>
                                <div class="input-group">
                                    <label for="dutyCycle" class="flex items-center text-sm font-medium text-gray-700 mb-2"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="h-5 w-5 mr-2 text-blue-600"><path d="M12 2v20"/><path d="M18 6l-6 6-6-6"/></svg>Duty Cycle (D)</label>
                                    <input type="number" id="dutyCycle" value="0.8" step="0.05" class="w-full bg-gray-50 text-gray-900 border border-gray-300 rounded-md p-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none">
                                </div>
                                <div class="input-group">
                                    <label for="maxTemperature" class="flex items-center text-sm font-medium text-gray-700 mb-2"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="h-5 w-5 mr-2 text-blue-600"><path d="M14 4v10.54a4 4 0 1 1-4 0V4a2 2 0 0 1 4 0Z"/></svg>Max Temp (Tmax) [°C]</label>
                                    <input type="number" id="maxTemperature" value="75" step="1" class="w-full bg-gray-50 text-gray-900 border border-gray-300 rounded-md p-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none">
                                </div>
                            </div>
                            <div class="input-group pt-2">
								<label for="coreType" class="flex items-center text-sm font-medium text-gray-700 mb-2"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="h-5 w-5 mr-2 text-blue-600"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"/><polyline points="3.27 6.96 12 12.01 20.73 6.96"/><line x1="12" x2="12" y1="22.08" y2="12"/></svg>Select Core Type</label>
								<select id="coreType" class="w-full bg-gray-50 text-gray-900 border border-gray-300 rounded-md p-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none"></select>
							</div>
							<div class="input-group">
								<label for="plotType" class="flex items-center text-sm font-medium text-gray-700 mb-2"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="h-5 w-5 mr-2 text-blue-600"><path d="M3 3v18h18"/><path d="M18 17V9"/><path d="M13 17V5"/><path d="M8 17v-3"/></svg>Select Plot</label>
								<select id="plotType" class="w-full bg-gray-50 text-gray-900 border border-gray-300 rounded-md p-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none">
									<option value="total_power_loss_vs_turns_combined">Total Power Loss vs Turns (Combined)</option>
									<option value="compare_core">Compare Core Losses</option>
									<option value="ku_vs_turns">Ku Factor vs Turns (Series)</option>
									<option value="total_power_loss_vs_turns_series">Total Power Loss vs Turns (Series)</option>
									<option value="total_power_loss_vs_turns_parallel">Total Power Loss vs Turns (Parallel)</option>
									<option value="copper_loss_vs_turns">Copper Loss vs Turns</option>
									<option value="loss_vs_turns">Core Loss vs Turns</option>
									<option value="flux_vs_turns">Flux Density vs Turns</option>
									<option value="layers_vs_turns">Number of Layers vs Turns</option>
								</select>
							</div>
                        </div>
						<div class="p-6 border-t border-gray-200">
							<button id="calculateButton" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg transition-all duration-200 transform hover:scale-105 flex items-center justify-center">
								<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor"><path d="M10.75 4.75a.75.75 0 0 0-1.5 0v4.5h-4.5a.75.75 0 0 0 0 1.5h4.5v4.5a.75.75 0 0 0 1.5 0v-4.5h4.5a.75.75 0 0 0 0-1.5h-4.5v-4.5z" /></svg>
								Calculate & Plot
							</button>
						</div>
                    </div>

                    <!-- Theory Section Card -->
                    <div class="bg-white border border-gray-200 rounded-xl shadow-md">
                        <details>
                            <summary class="p-6 flex justify-between items-center">
                                <h2 class="text-2xl font-semibold text-gray-800">Design Theory & Equations</h2>
                                <span class="text-blue-600 transform transition-transform duration-300 arrow">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" /></svg>
                                </span>
                            </summary>
                            <div class="px-6 pb-6 space-y-6 border-t border-gray-200 text-gray-700">
                                <div class="explanation-section">
									<h3 class="text-xl font-semibold text-gray-800 mt-4 mb-2">The Problem with Fill Factor ($K_u$)</h3>
									<p class="text-gray-600 leading-relaxed">
                                        Traditional transformer design often relies on the Fill Factor ($K_u$) to estimate the required core size. However, $K_u$ is not a fixed value; it depends on the wire size, insulation, and the number of turns—parameters that are not known at the start of the design.
                                    </p>
                                    <p class="text-gray-600 leading-relaxed">
                                        As the animated graph shows, the required core geometry is highly sensitive to $K_u$. A small change in the assumed Fill Factor can lead to a large change in the calculated core size, making the process iterative and prone to error.
                                    </p>
                                    <div class="my-6 flex justify-center">
                                        <img src="https://i.imgur.com/8YjZ1v4.png" alt="Graph showing Kgfe is inversely proportional to Ku" class="rounded-lg shadow-md animated-graph">
                                    </div>
                                    <p class="font-semibold text-gray-700 leading-relaxed">
                                        This tool avoids this issue by optimizing directly over the number of turns, a physical parameter, providing a more direct and accurate design process.
                                    </p>
								</div>
						
								<div class="explanation-section">
									<h3 class="text-xl font-semibold text-gray-800 mt-4 mb-2">Turns Ratio, Current & Winding Size</h3>
									<p class="text-gray-600 leading-relaxed">The output voltage for each mode is determined by the turns ratio and input voltage:</p>
									<div class="equation-block bg-gray-100 border-l-4 border-blue-500 p-4 rounded-md my-2 text-sm overflow-x-auto">
										$$ V_{out(series)} = 2 \cdot D_{eff} \cdot \frac{N_s}{N_p} \cdot \frac{V_{in}}{2} $$
                                        $$ V_{out(parallel)} = 2 \cdot D_{eff} \cdot \frac{N_s}{N_p} \cdot V_{in} $$
									</div>
                                    <p class="text-gray-600 leading-relaxed">RMS currents for the windings are calculated as:</p>
                                    <div class="equation-block bg-gray-100 border-l-4 border-blue-500 p-4 rounded-md my-2 text-sm overflow-x-auto">
										$$ I_{prms} = \frac{I_o}{2} \cdot \frac{N_s}{N_p} \cdot \sqrt{2D} $$
                                        $$ I_{srms} = \frac{I_o}{2} \cdot \sqrt{D} $$
									</div>
								</div>
                                
                                <div class="explanation-section">
									<h3 class="text-xl font-semibold text-gray-800 mt-4 mb-2">Setting Design Limits</h3>
									<p class="text-gray-600 leading-relaxed">The maximum flux density ($B_{max}$) is constrained by the core's thermal properties:</p>
									<div class="equation-block bg-gray-100 border-l-4 border-blue-500 p-4 rounded-md my-2 text-sm overflow-x-auto">
										$$ P_{max} = \frac{T_{max} - T_{min}}{R_{th}} $$
                                        $$ B_{max} = \left( \frac{P_{max}}{k f V_{core}} \right) ^ {\frac{1}{\beta}} $$
									</div>
                                    <p class="text-gray-600 leading-relaxed">The number of turns ($N_p$) must be within physical and magnetic limits:</p>
                                    <div class="equation-block bg-gray-100 border-l-4 border-blue-500 p-4 rounded-md my-2 text-sm overflow-x-auto">
										$$ N_{pmin} = \frac{V_{in} \cdot D}{2 f_s A_c B_{max}} $$
                                        $$ N_{pmax} \le \frac{K_u \cdot W_a}{S_p + \frac{S_s}{K}} $$
									</div>
								</div>
                            </div>
                        </details>
                    </div>
                </div>
            </div>

            <!-- === Right Column: Output === -->
            <div class="lg:col-span-2 space-y-8">
                
                <!-- Plot Card -->
                <div class="bg-white border border-gray-200 rounded-xl shadow-md min-h-[500px] flex items-center justify-center p-4">
                    <div id="plotDiv" class="w-full h-full relative">
                        <div class="loading-overlay hidden absolute inset-0 bg-white bg-opacity-75 flex items-center justify-center z-10 rounded-lg" id="loadingOverlay">
                            <div class="spinner"></div>
                        </div>
                        <div class="w-full h-full flex items-center justify-center">
                            <p class="text-gray-400">Select parameters and click 'Calculate & Plot' to see results.</p>
                        </div>
                    </div>
                </div>

                <!-- Loss Summary Table Card -->
                <div class="bg-white border border-gray-200 rounded-xl shadow-md">
                    <div class="p-6 border-b border-gray-200">
                        <h2 class="text-2xl font-semibold text-gray-800">Core Performance Summary</h2>
                    </div>
                    <div id="lossDiffTableContainer" class="p-2 md:p-4">
                        <div id="lossDiffTable" class="overflow-x-auto">
                            <!-- Table will be generated by JS here -->
                        </div>
                    </div>
                </div>
				
				<!-- Back Button -->
				<div class="flex justify-center mt-6">
					<a href="master_thesis_details.html" class="text-gray-500 hover:text-blue-600 transition-colors duration-200 flex items-center">
						<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M12.79 5.23a.75.75 0 0 1-.02 1.06L8.832 10l3.938 3.71a.75.75 0 1 1-1.04 1.08l-4.5-4.25a.75.75 0 0 1 0-1.08l4.5-4.25a.75.75 0 0 1 1.06.02Z" clip-rule="evenodd" /></svg>
						Back to Thesis Details
					</a>
				</div>
            </div>
        </div>
    </div>
	
	<script>
    // --- Core Data and Constants ---
    const colors = ['#3b82f6', '#ef4444', '#10b981', '#8b5cf6', '#f59e0b', '#ef4444', '#60a5fa', '#d946ef'];
    const core_names = ['EE10/11', 'EE13', 'EE16', 'EE19', 'EE25/19', 'EE30', 'EE40', 'EE50', 'EE60', 'ETD39', 'EE35', 'EE42', 'EE55'];
    const num_cores = core_names.length;
    const lms = [38.4, 45.4, 53.6, 66.8, 78.08, 94.2, 126.2, 156.2, 180.6, 149, 107.7, 144.55, 165.3].map(x => x * 1e-3);
    const Acs = [5.39, 8.82, 10, 11.96, 20.1528, 55, 66, 112.5, 123.2, 58.9, 45.2675, 118.69, 176.571].map(x => x * 1e-6);
    const Was = [46.62, 68.6, 82.8, 111.6, 158, 151.6, 328, 524, 814, 514, 93.7 * 2, 191.64 * 2, 331.82 * 2].map(x => x * 1e-6 / 2);
    const MLTs = [12, 15.4, 14, 15, 19.18, 32, 34, 45, 47.4, 40.21, 29.32, 42.45, 51.46].map(x => x * 1e-3);
    const hs = [4.2 * 2, 4.6 * 2, 5.0 * 2, 5.6 * 2, 6.41 * 2, 8.15 * 2, 10.25 * 2, 12.75 * 2, 14.05 * 2, 14.6 * 2, 9.71 * 2, 15.15 * 2, 18.8 * 2].map(x => x * 1e-3 - 4e-3);
    const Vse = lms.map((lm, i) => lm * Acs[i]);
    const lmp = [52.2, 60.4, 69, 78.8, 97.4, 115.4, 154.6, 191.6, 220, 184.2, 127.12, 174.85, 202.9].map(x => x * 1e-3);
    const Acp = Acs;
    const Wap = Was;
    const MLTp = MLTs;
    const hp = hs;
    const Vsp = lmp.map((lm, i) => lm * Acp[i]);
    const Rths = [63.8, 62.5, 76, 60, 41.49, 21.80, 16.87, 11.2, 9.925, 16.40, 22.53, 11.42, 8.572];
    const Rthp = [63.8, 62.5, 76, 60, 36.82, 19.54, 15.12, 10.10, 8.921, 14.63, 20.63, 10.31, 7.674];

    // --- Main Calculation Function ---
    function calculateLosses() {
        // Read input parameters
        const Po = parseFloat(document.getElementById('outputPower').value);
        const Vpp = parseFloat(document.getElementById('primaryVoltageParallel').value);
        const Vps = parseFloat(document.getElementById('primaryVoltageSeries').value);
        const f = parseFloat(document.getElementById('frequency').value);
        const D = parseFloat(document.getElementById('dutyCycle').value);
        const Tmax = parseFloat(document.getElementById('maxTemperature').value);
        const selectedCoreIndex = parseInt(document.getElementById('coreType').value);

        // Fixed parameters from original code
        const Vd = 1.4;
        const dps = 0.0008;
        const dpp = dps;
        const ds = 0.000812;
        const Tamb = 25;
        const k = 0.160e3;
        const alpha = 1.078;
        const Beta = 2.92;
        const Vs1 = 24;
        const Vs2 = 24;
        const ns = 3;
        const np = 3;

        // Intermediate calculations
        const I24 = Po / 2 / (Vs2 + 2 * Vd);
        const Isrms = ((Vs1 / Vps) * I24 + (Vs2 / Vps) * I24) * Math.sqrt(D);
        const Iprms = ((Vs1 / Vpp) * I24 + (Vs2 / Vpp) * I24) * Math.sqrt(D);
        const I01rms = (1 / 2) * (I24 * Math.sqrt(1 + D));
        const Awps = 2 * Math.PI * (dps / 2)**2;
        const Awpp = 2 * Math.PI * (dpp / 2)**2;
        const Aws = Math.PI * (ds / 2)**2;
        const rho = 1.724e-8;
        const muc = 1.256629e-6;
        const Sd = Math.sqrt(rho * (1 + 0.0393 * (Tmax - 25)) / (Math.PI * f * muc));
        const nus = (Math.sqrt(Math.PI) * dps) / (2 * (dps + 0.051e-3));
        const nup = (Math.sqrt(Math.PI) * dpp) / (2 * (dpp + 0.051e-3));
        const deltaps = (Math.PI / 4)**0.75 * (dps / Sd) * Math.sqrt(nus);
        const deltapp = (Math.PI / 4)**0.75 * (dpp / Sd) * Math.sqrt(nup);
        const deltas = (Math.PI / 4)**0.75 * (ds / Sd) * Math.sqrt(nup);
        const Skeffs = (Math.sinh(2 * deltaps) + Math.sin(2 * deltaps)) / (Math.cosh(2 * deltaps) - Math.cos(2 * deltaps));
        const Skeffp = (Math.sinh(2 * deltapp) + Math.sin(2 * deltapp)) / (Math.cosh(2 * deltapp) + Math.cos(2 * deltapp));
        const Proxeffs = (Math.sinh(deltaps) - Math.sin(deltaps)) / (Math.cosh(deltaps) + Math.cos(deltaps));
        const Proxeffp = (Math.sinh(deltapp) - Math.sin(deltapp)) / (Math.cosh(deltapp) + Math.cos(deltapp));

        const allCoresLossSummary = [];
        const selectedCoreResults = {
            selectedCoreIndex: selectedCoreIndex,
            Turns: { Series: { Primary: [] }, Parallel: { Primary: [] } },
            Flux: { Series: [], Parallel: [] },
            Pfes: [], Pfep: [],
            CopperLoss: { Series: [], Parallel: [] },
            PowerLoss: { Series: [], Parallel: [] },
            Ku: { Series: [] },
            Optimal: {
                Series: { Power: NaN, B: NaN, Np: NaN },
                Parallel: { Power: NaN, B: NaN, Np: NaN }
            },
            Pmaxs: NaN, Pmaxp: NaN
        };
        
        // Loop through all cores
        for (let i = 0; i < num_cores; i++) {
            const Pmax_series_core = (Tmax - Tamb) / Rths[i];
            const Pmax_parallel_core = (Tmax - Tamb) / Rthp[i];
            const Bsmax_core = (Pmax_series_core / (k * f**alpha * Vse[i]))**(1/Beta);
            const Bpmax_core = (Pmax_parallel_core / (k * f**alpha * Vsp[i]))**(1/Beta);
            const Npsmax_core = (0.78 * Was[i]) / (Awps + Aws / ns);
            const Nppmax_core = (0.78 * Wap[i]) / (Awpp + Aws / np);
            
            let Nps_range_core = [];
            const Nps_min_core = Math.ceil((0.5 * Vps * D) / (2 * Acs[i] * f * Bsmax_core));
            if (isFinite(Nps_min_core) && Nps_min_core <= Npsmax_core) {
                for (let n = Nps_min_core; n <= Npsmax_core; n++) { Nps_range_core.push(n); }
            }

            let Npp_range_core = [];
            const Npp_min_core = Math.ceil((Vpp * D) / (2 * Acp[i] * f * Bpmax_core));
            if (isFinite(Npp_min_core) && Npp_min_core <= Nppmax_core) {
                for (let n = Npp_min_core; n <= Nppmax_core; n++) { Npp_range_core.push(n); }
            }
            
            const B_series_full_core = Nps_range_core.map(Np => (0.5 * Vps * D) / (2 * Acs[i] * f * Np));
            const B_parallel_full_core = Npp_range_core.map(Np => (Vpp * D) / (2 * Acp[i] * f * Np));
            
            const Nps_valid_core = Nps_range_core.filter((_, idx) => B_series_full_core[idx] <= Bsmax_core);
            const Npp_valid_core = Npp_range_core.filter((_, idx) => B_parallel_full_core[idx] <= Bpmax_core);
            
            const B_series_core = Nps_valid_core.map(Np => (0.5 * Vps * D) / (2 * Acs[i] * f * Np));
            const B_parallel_core = Npp_valid_core.map(Np => (Vpp * D) / (2 * Acp[i] * f * Np));

            const Pfes_core = B_series_core.map(B => k * f**alpha * B**Beta * Acs[i] * lms[i]);
            const Pfep_core = B_parallel_core.map(B => k * f**alpha * B**Beta * Acp[i] * lmp[i]);
            
            const Ns_series_core = Nps_valid_core.map(Np => Np / ns);
            const Ns_parallel_core = Npp_valid_core.map(Np => Np / np);

            const Lfactor_series_primary_core = Nps_valid_core.map(Np => (2 * (Math.max((0.5 * Np * dps) / hs[i], 1)**2) - 1) / 3);
            const Lfactor_series_secondary_core = Ns_series_core.map(Ns => (2 * (Math.max((0.5 * Ns * ds) / hs[i], 1)**2) - 1) / 3);
            const Fr_series_primary_core = Lfactor_series_primary_core.map(Lfactor => deltaps * (Skeffs + Lfactor * Proxeffs));
            const Fr_series_secondary_core = Lfactor_series_secondary_core.map(Lfactor => deltas * (Skeffs + Lfactor * Proxeffs));
            const Resistance_series_primary_core = Fr_series_primary_core.map((Fr, idx) => Fr * Nps_valid_core[idx] * (rho / Awps) * MLTs[i]);
            const Resistance_series_secondary_core = Fr_series_secondary_core.map((Fr, idx) => Fr * Ns_series_core[idx] * (rho / Aws) * MLTs[i]);
            const CopperLoss_series_core = Resistance_series_primary_core.map((R_p, idx) => R_p * Isrms**2 + Resistance_series_secondary_core[idx] * I01rms**2);
            const PowerLoss_series_core = CopperLoss_series_core.map((Closs, idx) => Closs + Pfes_core[idx]);

            const Lfactor_parallel_primary_core = Npp_valid_core.map(Np => (2 * (Math.max((0.5 * Np * dpp) / hp[i], 1)**2) - 1) / 3);
            const Lfactor_parallel_secondary_core = Ns_parallel_core.map(Ns => (2 * (Math.max((0.5 * Ns * ds) / hp[i], 1)**2) - 1) / 3);
            const Fr_parallel_primary_core = Lfactor_parallel_primary_core.map(Lfactor => deltapp * (Skeffp + Lfactor * Proxeffp));
            const Fr_parallel_secondary_core = Lfactor_parallel_secondary_core.map(Lfactor => deltas * (Skeffp + Lfactor * Proxeffp));
            const Resistance_parallel_primary_core = Fr_parallel_primary_core.map((Fr, idx) => Fr * Npp_valid_core[idx] * (rho / Awpp) * MLTp[i]);
            const Resistance_parallel_secondary_core = Fr_parallel_secondary_core.map((Fr, idx) => Fr * Ns_parallel_core[idx] * (rho / Aws) * MLTp[i]);
            const CopperLoss_parallel_core = Resistance_parallel_primary_core.map((R_p, idx) => 0.5 * R_p * (0.5 * Iprms)**2 + Resistance_parallel_secondary_core[idx] * I01rms**2);
            const PowerLoss_parallel_core = CopperLoss_parallel_core.map((Closs, idx) => Closs + Pfep_core[idx]);

            let optimalSeriesPower = Math.min(...PowerLoss_series_core);
            let optimalSeriesNp = Nps_valid_core[PowerLoss_series_core.indexOf(optimalSeriesPower)];
            let optimalParallelPower = Math.min(...PowerLoss_parallel_core);
            let optimalParallelNp = Npp_valid_core[PowerLoss_parallel_core.indexOf(optimalParallelPower)];

            allCoresLossSummary.push({
                coreName: core_names[i],
                OptimalSeriesPower: isFinite(optimalSeriesPower) ? optimalSeriesPower : NaN,
                OptimalSeriesNp: optimalSeriesNp,
                OptimalParallelPower: isFinite(optimalParallelPower) ? optimalParallelPower : NaN,
                OptimalParallelNp: optimalParallelNp
            });

            if (i === selectedCoreIndex) {
                Object.assign(selectedCoreResults, {
                    Turns: { Series: { Primary: Nps_valid_core }, Parallel: { Primary: Npp_valid_core } },
                    Flux: { Series: B_series_core, Parallel: B_parallel_core },
                    Pfes: Pfes_core, Pfep: Pfep_core,
                    CopperLoss: { Series: CopperLoss_series_core, Parallel: CopperLoss_parallel_core },
                    PowerLoss: { Series: PowerLoss_series_core, Parallel: PowerLoss_parallel_core },
                    Pmaxs: Pmax_series_core, Pmaxp: Pmax_parallel_core,
                    Optimal: {
                        Series: { Power: optimalSeriesPower, Np: optimalSeriesNp, B: B_series_core[PowerLoss_series_core.indexOf(optimalSeriesPower)] },
                        Parallel: { Power: optimalParallelPower, Np: optimalParallelNp, B: B_parallel_core[PowerLoss_parallel_core.indexOf(optimalParallelPower)] }
                    }
                });
                
                // Simplified Ku calculation for plotting
                const A_copper_total_series = Nps_valid_core.map((Np, j) => Np * Awps + Ns_series_core[j] * Aws);
                selectedCoreResults.Ku.Series = A_copper_total_series.map(A_copper => A_copper / Was[i]);
            }
        }
        return { selectedCoreResults, allCoresLossSummary };
    }

    // --- Plotting and UI Update Functions ---
    function getPlotlyLayout(title) {
        return {
            title: { text: title, font: { color: '#1f2937' } }, // gray-800
            xaxis: { gridcolor: '#e5e7eb', titlefont: { color: '#4b5563' }, tickfont: { color: '#4b5563' } }, // gray-200, gray-600
            yaxis: { gridcolor: '#e5e7eb', titlefont: { color: '#4b5563' }, tickfont: { color: '#4b5563' } }, // gray-200, gray-600
            hovermode: 'x unified',
            showlegend: true,
            paper_bgcolor: 'transparent',
            plot_bgcolor: 'transparent',
            legend: { font: { color: '#374151' }, orientation: 'h', y: -0.2, x: 0.5, xanchor: 'center' }, // gray-700
            margin: { l: 60, r: 30, b: 80, t: 50 }
        };
    }
    
    function plotData(data, plotDivId, plotConfig) {
        const traces = plotConfig.traces(data);
        // Check if all trace arrays are empty or undefined
        const isDataEmpty = traces.every(t => !t.x || t.x.length === 0);

        if (isDataEmpty) {
             document.getElementById(plotDivId).innerHTML = `<div class="w-full h-full flex items-center justify-center"><p class="text-gray-400">No valid data to plot for the selected parameters.</p></div>`;
             return;
        }
        const layout = getPlotlyLayout(plotConfig.title);
        layout.xaxis.title = { text: plotConfig.xaxis };
        layout.yaxis.title = { text: plotConfig.yaxis };
        Plotly.newPlot(plotDivId, traces, layout, {responsive: true});
    }

    const plotConfigs = {
        loss_vs_turns: {
            title: 'Core Loss vs. Primary Turns', xaxis: 'Primary Turns (Np)', yaxis: 'Core Loss (W)',
            traces: (d) => [{ x: d.Turns.Series.Primary, y: d.Pfes, mode: 'lines', name: 'Series', line: {color: colors[0]} }, { x: d.Turns.Parallel.Primary, y: d.Pfep, mode: 'lines', name: 'Parallel', line: {color: colors[1], dash: 'dash'} }]
        },
        flux_vs_turns: {
            title: 'Flux Density vs. Primary Turns', xaxis: 'Primary Turns (Np)', yaxis: 'Flux Density (T)',
            traces: (d) => [{ x: d.Turns.Series.Primary, y: d.Flux.Series, mode: 'lines', name: 'Series', line: {color: colors[0]} }, { x: d.Turns.Parallel.Primary, y: d.Flux.Parallel, mode: 'lines', name: 'Parallel', line: {color: colors[1], dash: 'dash'} }]
        },
        copper_loss_vs_turns: {
            title: 'Copper Loss vs. Primary Turns', xaxis: 'Primary Turns (Np)', yaxis: 'Copper Loss (W)',
            traces: (d) => [{ x: d.Turns.Series.Primary, y: d.CopperLoss.Series, mode: 'lines', name: 'Series', line: {color: colors[0]} }, { x: d.Turns.Parallel.Primary, y: d.CopperLoss.Parallel, mode: 'lines', name: 'Parallel', line: {color: colors[1], dash: 'dash'} }]
        },
        total_power_loss_vs_turns_combined: {
            title: 'Total Power Loss vs. Primary Turns', xaxis: 'Primary Turns (Np)', yaxis: 'Total Power Loss (W)',
            traces: (d) => [
                { x: d.Turns.Series.Primary, y: d.PowerLoss.Series, mode: 'lines', name: 'Total Loss (Series)', line: {color: colors[0]} },
                { x: d.Turns.Parallel.Primary, y: d.PowerLoss.Parallel, mode: 'lines', name: 'Total Loss (Parallel)', line: {color: colors[1], dash: 'dash'} },
                { x: [d.Optimal.Series.Np], y: [d.Optimal.Series.Power], mode: 'markers', name: 'Optimal (S)', marker: {color: colors[0], symbol: 'star', size: 12} },
                { x: [d.Optimal.Parallel.Np], y: [d.Optimal.Parallel.Power], mode: 'markers', name: 'Optimal (P)', marker: {color: colors[1], symbol: 'star', size: 12} }
            ]
        },
        ku_vs_turns: {
            title: 'Window Utilization (Ku) vs. Primary Turns', xaxis: 'Primary Turns (Np)', yaxis: 'Ku Factor',
            traces: (d) => [{ x: d.Turns.Series.Primary, y: d.Ku.Series, mode: 'lines', name: 'Ku (Series)', line: {color: colors[0]} }]
        },
        compare_core: {
            title: 'Optimal Total Power Loss per Core Type', xaxis: 'Core Type', yaxis: 'Optimal Total Loss (W)',
            traces: (d) => [
                { x: d.map(c => c.coreName), y: d.map(c => c.OptimalSeriesPower), type: 'bar', name: 'Series', marker: {color: colors[0]} },
                { x: d.map(c => c.coreName), y: d.map(c => c.OptimalParallelPower), type: 'bar', name: 'Parallel', marker: {color: colors[1]} }
            ]
        }
    };
    plotConfigs.total_power_loss_vs_turns_series = { ...plotConfigs.total_power_loss_vs_turns_combined, title: 'Total Power Loss vs. Primary Turns (Series)', traces: (d) => [plotConfigs.total_power_loss_vs_turns_combined.traces(d)[0], plotConfigs.total_power_loss_vs_turns_combined.traces(d)[2]] };
    plotConfigs.total_power_loss_vs_turns_parallel = { ...plotConfigs.total_power_loss_vs_turns_combined, title: 'Total Power Loss vs. Primary Turns (Parallel)', traces: (d) => [plotConfigs.total_power_loss_vs_turns_combined.traces(d)[1], plotConfigs.total_power_loss_vs_turns_combined.traces(d)[3]] };
    plotConfigs.layers_vs_turns = { ...plotConfigs.ku_vs_turns, title: 'Number of Layers vs. Primary Turns', yaxis: 'Layers (Approx.)'}; // Re-using Ku for layer plot as an example

    function updateLossDiffTable(summaryData) {
        const tableContainer = document.getElementById('lossDiffTable');
        let tableHTML = `<table class="w-full text-sm text-left text-gray-700">
            <thead class="text-xs text-gray-700 uppercase bg-gray-100">
                <tr>
                    <th scope="col" class="px-6 py-3">Core Type</th>
                    <th scope="col" class="px-6 py-3">Optimal Series Loss [W] (Np)</th>
                    <th scope="col" class="px-6 py-3">Optimal Parallel Loss [W] (Np)</th>
                </tr>
            </thead><tbody>`;
        summaryData.forEach(core => {
            const seriesText = !isNaN(core.OptimalSeriesPower) ? `${core.OptimalSeriesPower.toFixed(2)} (${core.OptimalSeriesNp || 'N/A'})` : 'N/A';
            const parallelText = !isNaN(core.OptimalParallelPower) ? `${core.OptimalParallelPower.toFixed(2)} (${core.OptimalParallelNp || 'N/A'})` : 'N/A';
            tableHTML += `<tr class="bg-white border-b hover:bg-gray-50">
                <th scope="row" class="px-6 py-4 font-medium text-gray-900 whitespace-nowrap">${core.coreName}</th>
                <td class="px-6 py-4">${seriesText}</td>
                <td class="px-6 py-4">${parallelText}</td></tr>`;
        });
        tableHTML += `</tbody></table>`;
        tableContainer.innerHTML = tableHTML;
    }

    // --- Event Listeners and Initialization ---
    document.getElementById('calculateButton').addEventListener('click', () => {
        const plotDiv = document.getElementById('plotDiv');
        const loadingOverlay = document.getElementById('loadingOverlay');
        loadingOverlay.classList.remove('hidden');
        plotDiv.innerHTML = ''; // Clear previous plot or message
        
        setTimeout(() => {
            try {
                const { selectedCoreResults, allCoresLossSummary } = calculateLosses();
                const plotType = document.getElementById('plotType').value;
                const config = plotConfigs[plotType] || plotConfigs.total_power_loss_vs_turns_combined;
                
                const dataToPlot = plotType === 'compare_core' ? allCoresLossSummary : selectedCoreResults;
                plotData(dataToPlot, 'plotDiv', config);
                
                updateLossDiffTable(allCoresLossSummary);
            } catch (error) {
                console.error("Error during calculation or plotting:", error);
                plotDiv.innerHTML = `<div class="w-full h-full flex items-center justify-center"><p class="text-red-600">Error: ${error.message}. Check console.</p></div>`;
            } finally {
                loadingOverlay.classList.add('hidden');
            }
        }, 50);
    });

    document.addEventListener('DOMContentLoaded', () => {
        const coreTypeSelect = document.getElementById('coreType');
        core_names.forEach((name, index) => {
            const option = document.createElement('option');
            option.value = index;
            option.textContent = name;
            coreTypeSelect.appendChild(option);
        });
        document.getElementById('calculateButton').click();
    });
	</script>
</body>
</html>
