<!DOCTYPE html>
<html lang="en" class="bg-slate-900">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Transformer Design Analysis Dashboard</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
    
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
        /* Base styles for the page */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0f172a; /* bg-slate-900 */
            color: #cbd5e1; /* text-slate-300 */
        }

        /* Styling for Plotly's dark theme to ensure text is visible */
        .plotly-dark .xtitle, .plotly-dark .ytitle, .plotly-dark .legendtext {
            fill: #94a3b8 !important; /* slate-400 */
        }
        .plotly-dark .tick text {
            fill: #94a3b8 !important; /* slate-400 */
        }

        /* Custom spinner for loading overlay */
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-left-color: #22d3ee; /* cyan-400 */
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Custom styles for the collapsible details/summary element */
        details > summary {
            list-style: none;
            cursor: pointer;
        }
        details > summary::-webkit-details-marker {
            display: none;
        }
        details[open] summary .arrow {
            transform: rotate(90deg);
        }
    </style>
</head>
<body class="p-4 md:p-8">

    <div class="max-w-7xl mx-auto">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-white mb-2">Transformer Design Analysis Dashboard</h1>
            <p class="text-lg text-slate-400">An interactive tool for high-frequency transformer optimization.</p>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">

            <div class="lg:col-span-1">
                <div class="sticky top-8 space-y-8">
                    
                    <div class="bg-slate-800 border border-slate-700 rounded-xl shadow-lg">
                        <div class="p-6 border-b border-slate-700">
                            <h2 class="text-2xl font-semibold text-white">Design Parameters</h2>
                        </div>
                        <div class="p-6 space-y-4 max-h-[75vh] overflow-y-auto">
                            <div class="input-group">
								<label for="outputPower" class="flex items-center text-sm font-medium text-slate-300 mb-2">
									<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2 text-cyan-400" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z" /></svg>
									Output Power (Po) [W]
								</label>
								<input type="number" id="outputPower" value="500" step="10" class="w-full bg-slate-700 text-white border border-slate-600 rounded-md p-2 focus:ring-2 focus:ring-cyan-400 focus:border-cyan-400 outline-none">
							</div>
							<div class="input-group">
								<label for="primaryVoltageParallel" class="flex items-center text-sm font-medium text-slate-300 mb-2">
									<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2 text-cyan-400" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd" /></svg>
									Primary Voltage (Vpp) [V]
								</label>
								<input type="number" id="primaryVoltageParallel" value="80" step="5" class="w-full bg-slate-700 text-white border border-slate-600 rounded-md p-2 focus:ring-2 focus:ring-cyan-400 focus:border-cyan-400 outline-none">
							</div>
							<div class="input-group">
								<label for="primaryVoltageSeries" class="flex items-center text-sm font-medium text-slate-300 mb-2">
								<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2 text-cyan-400"  viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-align-vertical-space-around"><rect width="6" height="6" x="9" y="1" rx="1"/><path d="M4 22h16"/><rect width="6" height="6" x="9" y="15" rx="1"/><path d="M4 11h16"/></svg>
									Primary Voltage (Vps) [V]
								</label>
								<input type="number" id="primaryVoltageSeries" value="160" step="5" class="w-full bg-slate-700 text-white border border-slate-600 rounded-md p-2 focus:ring-2 focus:ring-cyan-400 focus:border-cyan-400 outline-none">
							</div>
							<div class="input-group">
								<label for="frequency" class="flex items-center text-sm font-medium text-slate-300 mb-2">
									<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2 text-cyan-400" viewBox="0 0 20 20" fill="currentColor"><path d="M2 10.5a1.5 1.5 0 113 0v6a1.5 1.5 0 01-3 0v-6zM6 10.333V17a1 1 0 001 1h2a1 1 0 001-1v-6.667a1 1 0 00-.323-.747L8.5 8.25a1 1 0 00-1.053.053L6 10.333zM18 10.5a1.5 1.5 0 11-3 0v6a1.5 1.5 0 013 0v-6zM14 10.333V17a1 1 0 01-1 1h-2a1 1 0 01-1-1v-6.667a1 1 0 01.323-.747l1.177-1.333a1 1 0 011.053.053L14 10.333z" /></svg>
									Frequency (f) [Hz]
								</label>
								<input type="number" id="frequency" value="100000" step="1000" class="w-full bg-slate-700 text-white border border-slate-600 rounded-md p-2 focus:ring-2 focus:ring-cyan-400 focus:border-cyan-400 outline-none">
							</div>
							<div class="input-group">
								<label for="dutyCycle" class="flex items-center text-sm font-medium text-slate-300 mb-2">
									<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2 text-cyan-400" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M4 2a2 2 0 00-2 2v12a2 2 0 002 2h12a2 2 0 002-2V4a2 2 0 00-2-2H4zm8.5 3.5a.5.5 0 00-1 0V9a.5.5 0 00.5.5h4a.5.5 0 000-1h-3.5V5.5z" clip-rule="evenodd" /></svg>
									Duty Cycle (D)
								</label>
								<input type="number" id="dutyCycle" value="0.8" step="0.05" class="w-full bg-slate-700 text-white border border-slate-600 rounded-md p-2 focus:ring-2 focus:ring-cyan-400 focus:border-cyan-400 outline-none">
							</div>
							<div class="input-group">
								<label for="coreType" class="flex items-center text-sm font-medium text-slate-300 mb-2">
									<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2 text-cyan-400" viewBox="0 0 20 20" fill="currentColor"><path d="M5 3a2 2 0 00-2 2v2a2 2 0 002 2h2a2 2 0 002-2V5a2 2 0 00-2-2H5zM5 11a2 2 0 00-2 2v2a2 2 0 002 2h2a2 2 0 002-2v-2a2 2 0 00-2-2H5zM11 5a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V5zM11 13a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z" /></svg>
									Select Core Type
								</label>
								<select id="coreType" class="w-full bg-slate-700 text-white border border-slate-600 rounded-md p-2 focus:ring-2 focus:ring-cyan-400 focus:border-cyan-400 outline-none"></select>
							</div>
							<div class="input-group">
								<label for="plotType" class="flex items-center text-sm font-medium text-slate-300 mb-2">
									<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2 text-cyan-400" viewBox="0 0 20 20" fill="currentColor"><path d="M2 11a1 1 0 011-1h2a1 1 0 011 1v5a1 1 0 01-1 1H3a1 1 0 01-1-1v-5zM8 7a1 1 0 011-1h2a1 1 0 011 1v9a1 1 0 01-1 1H9a1 1 0 01-1-1V7zM14 4a1 1 0 011-1h2a1 1 0 011 1v12a1 1 0 01-1 1h-2a1 1 0 01-1-1V4z" /></svg>
									Select Plot
								</label>
								<select id="plotType" class="w-full bg-slate-700 text-white border border-slate-600 rounded-md p-2 focus:ring-2 focus:ring-cyan-400 focus:border-cyan-400 outline-none">
									<option value="total_power_loss_vs_turns_combined">Total Power Loss vs Turns (Combined)</option>
									<option value="compare_core">Compare Core Losses</option>
									<option value="ku_vs_turns">Ku Factor vs Turns (Series)</option>
									<option value="total_power_loss_vs_turns_series">Total Power Loss vs Turns (Series)</option>
									<option value="total_power_loss_vs_turns_parallel">Total Power Loss vs Turns (Parallel)</option>
									<option value="copper_loss_vs_turns">Copper Loss vs Turns</option>
									<option value="loss_vs_turns">Core Loss vs Turns</option>
									<option value="flux_vs_turns">Flux Density vs Turns</option>
									<option value="layers_vs_turns">Number of Layers vs Turns</option>
								</select>
							</div>

                        </div>
						<div class="p-6 border-t border-slate-700">
							<button id="calculateButton" class="w-full bg-cyan-500 hover:bg-cyan-400 text-slate-900 font-bold py-3 px-4 rounded-lg transition-all duration-200 transform hover:scale-105 flex items-center justify-center">
								<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-11a1 1 0 10-2 0v2H7a1 1 0 100 2h2v2a1 1 0 102 0v-2h2a1 1 0 100-2h-2V7z" clip-rule="evenodd" /></svg>
								Calculate & Plot
							</button>
						</div>
                    </div>

                    <div class="bg-slate-800 border border-slate-700 rounded-xl shadow-lg">
                        <details>
                            <summary class="p-6 flex justify-between items-center">
                                <h2 class="text-2xl font-semibold text-white">Design Theory & Equations</h2>
                                <span class="text-cyan-400 transform transition-transform arrow">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" /></svg>
                                </span>
                            </summary>
                            <div class="px-6 pb-6 space-y-6 border-t border-slate-700 text-slate-300">
                                <div class="explanation-section">
									<h3 class="text-xl font-semibold text-white mt-4 mb-2">Introduction to High-Frequency Transformer Design</h3>
									<p class="text-slate-400 leading-relaxed">High-frequency transformers are indispensable components in modern power converters... The primary goal was to achieve a robust and efficient magnetic component...</p>
								</div>
						
								<div class="explanation-section">
									<h3 class="text-xl font-semibold text-white mt-4 mb-2">Core Selection and Material Properties</h3>
									<p class="text-slate-400 leading-relaxed">The selection of an appropriate magnetic core material and geometry is the first critical step... These parameters are fundamental for calculating flux density, winding lengths, and thermal performance.</p>
								</div>
						
								<div class="explanation-section">
									<h3 class="text-xl font-semibold text-white mt-4 mb-2">Fundamental Design Equations</h3>
									<p class="text-slate-400 leading-relaxed">The transformer design process involves several iterative calculations to determine optimal turns, wire gauges, and minimize losses.</p>
						
									<h4 class="font-semibold text-slate-200 mt-3 mb-1">Faraday's Law for Primary Turns Calculation:</h4>
									<div class="equation-block bg-slate-900 border-l-4 border-cyan-400 p-4 rounded-md my-2 text-sm">
										$$ N_p = \frac{V_{in}}{2 \cdot f \cdot B_{max} \cdot A_e} $$
									</div>
						
									<h4 class="font-semibold text-slate-200 mt-3 mb-1">Core Loss Calculation (Steinmetz Equation):</h4>
									<div class="equation-block bg-slate-900 border-l-4 border-cyan-400 p-4 rounded-md my-2 text-sm">
										$$ P_{core} = k \cdot f^{\alpha} \cdot B_{ac}^{\beta} \cdot V_e $$
									</div>
						
									<h4 class="font-semibold text-slate-200 mt-3 mb-1">Copper Loss Calculation:</h4>
									<div class="equation-block bg-slate-900 border-l-4 border-cyan-400 p-4 rounded-md my-2 text-sm">
										$$ P_{copper} = I_{rms}^2 \cdot R_{ac} $$
									</div>
								</div>
                            </div>
                        </details>
                    </div>
                </div>
            </div>

            <div class="lg:col-span-2 space-y-8">
                
                <div class="bg-slate-800 border border-slate-700 rounded-xl shadow-lg min-h-[500px] flex items-center justify-center p-4">
                    <div id="plotDiv" class="w-full h-full relative">
                        <div class="loading-overlay hidden absolute inset-0 bg-slate-800 bg-opacity-75 flex items-center justify-center z-10" id="loadingOverlay">
                            <div class="spinner"></div>
                        </div>
                        <p class="text-slate-500">Select parameters and click 'Calculate & Plot' to see results.</p>
                    </div>
                </div>

                <div class="bg-slate-800 border border-slate-700 rounded-xl shadow-lg">
                    <div class="p-6 border-b border-slate-700">
                        <h2 class="text-2xl font-semibold text-white">Core Performance Summary</h2>
                    </div>
                    <div id="lossDiffTableContainer" class="p-2 md:p-4">
                        <div id="lossDiffTable" class="overflow-x-auto">
                            </div>
                    </div>
                </div>
				
				<div class="flex justify-center mt-6">
					<a href="master_thesis_details.html" class="text-slate-400 hover:text-white transition-colors duration-200 flex items-center">
						<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M9.707 16.707a1 1 0 01-1.414 0l-6-6a1 1 0 010-1.414l6-6a1 1 0 011.414 1.414L5.414 9H17a1 1 0 110 2H5.414l4.293 4.293a1 1 0 010 1.414z" clip-rule="evenodd" /></svg>
						Back to Thesis Details
					</a>
				</div>
            </div>
        </div>
    </div>
	<script>
	// Your existing JavaScript code goes here.
	// Find this line in your plotting functions: `const layout = { ... };`
	// And add this property to each layout object to enable the dark theme:
	// template: 'plotly_dark'
	
	// Example modification for one plot function:
	function plotLossVsFlux(data, plotDivId) {
		// ... (your existing trace setup) ...
		const traces = [];
		const colorMap = colors.map(c => `rgb(${c[0]*255},${c[1]*255},${c[2]*255})`);
		const selectedCoreName = core_names[data.selectedCoreIndex];

		if (data.Flux.Series && data.Pfes && data.Flux.Series.length > 0) {
			traces.push({
				x: data.Flux.Series,
				y: data.Pfes,
				mode: 'lines',
				name: `${selectedCoreName}-S`,
				line: { color: colorMap[data.selectedCoreIndex % colors.length], width: 2 }
			});
		}
		if (data.Flux.Parallel && data.Pfep && data.Flux.Parallel.length > 0) {
			traces.push({
				x: data.Flux.Parallel,
				y: data.Pfep,
				mode: 'lines',
				name: `${selectedCoreName}-P`,
				line: { color: colorMap[data.selectedCoreIndex % colors.length], dash: 'dash', width: 2 }
			});
		}
	
		const layout = {
			title: {
				text: `Core Loss vs. Flux Density for ${selectedCoreName}`,
				font: { color: 'white' }
			},
			xaxis: { 
				title: 'Flux Density (Tesla)',
				gridcolor: 'rgba(255, 255, 255, 0.1)',
				titlefont: { color: '#94a3b8' },
				tickfont: { color: '#94a3b8' }
			},
			yaxis: { 
				title: 'Core Loss (W)',
				gridcolor: 'rgba(255, 255, 255, 0.1)',
				titlefont: { color: '#94a3b8' },
				tickfont: { color: '#94a3b8' }
			},
			hovermode: 'closest',
			showlegend: true,
			paper_bgcolor: 'transparent', // Make chart background transparent
			plot_bgcolor: 'transparent',
			legend: {
				font: { color: '#cbd5e1' } // slate-300
			}
		};
		Plotly.newPlot(plotDivId, traces, layout, {responsive: true});
	}

	// NOTE: You would apply similar layout changes to all your other plot functions
	// (plotLossVsTurns, plotTotalPowerLossVsTurnsCombined, etc.) for a consistent look.

	// Function to update the summary table with new classes
	function updateLossDiffTable(summaryData) {
		const tableContainer = document.getElementById('lossDiffTable');
		let tableHTML = `
			<table class="w-full text-sm text-left text-slate-300">
				<thead class="text-xs text-slate-400 uppercase bg-slate-700">
					<tr>
						<th scope="col" class="px-6 py-3">Core Type</th>
						<th scope="col" class="px-6 py-3">Optimal Series Loss [W] (Np)</th>
						<th scope="col" class="px-6 py-3">Optimal Parallel Loss [W] (Np)</th>
					</tr>
				</thead>
				<tbody>
		`;

		summaryData.forEach(core => {
			const optimalSeriesText = !isNaN(core.OptimalSeriesPower) ? `${core.OptimalSeriesPower.toFixed(2)} (${core.OptimalSeriesNp})` : 'N/A';
			const optimalParallelText = !isNaN(core.OptimalParallelPower) ? `${core.OptimalParallelPower.toFixed(2)} (${core.OptimalParallelNp})` : 'N/A';
			tableHTML += `
				<tr class="bg-slate-800 border-b border-slate-700 hover:bg-slate-600">
					<th scope="row" class="px-6 py-4 font-medium text-white whitespace-nowrap">${core.coreName}</th>
					<td class="px-6 py-4">${optimalSeriesText}</td>
					<td class="px-6 py-4">${optimalParallelText}</td>
				</tr>
			`;
		});

		tableHTML += `
				</tbody>
			</table>
		`;
		tableContainer.innerHTML = tableHTML;
	}
	
	// --- PASTE THE REST OF YOUR ORIGINAL JAVASCRIPT HERE ---
	// (The calculateLosses function and all other functions)
    const colors = [
            [1, 0, 1], [1, 0, 0], [0, 1, 0], [0, 0, 1], [0, 1, 1],
            [0, 0, 0], [1, 0.5, 0], [0.5, 0, 0.5], [0.5, 0.5, 0], [0.2, 0.6, 1],
            [1, 0.2, 0.2], [0.3, 0.3, 0.3], [0.8, 0.4, 0]
        ];

        const core_names = ['EE10/11', 'EE13', 'EE16', 'EE19', 'EE25/19', 'EE30', 'EE40', 'EE50', 'EE60', 'ETD39', 'EE35', 'EE42', 'EE55'];
        const num_cores = core_names.length;

        const lms = [38.4, 45.4, 53.6, 66.8, 78.08, 94.2, 126.2, 156.2, 180.6, 149, 107.7, 144.55, 165.3].map(x => x * 1e-3);
        const Acs = [5.39, 8.82, 10, 11.96, 20.1528, 55, 66, 112.5, 123.2, 58.9, 45.2675, 118.69, 176.571].map(x => x * 1e-6);
        const Was = [46.62, 68.6, 82.8, 111.6, 158, 151.6, 328, 524, 814, 514, 93.7 * 2, 191.64 * 2, 331.82 * 2].map(x => x * 1e-6 / 2); // Divided by 2 as per MATLAB comments
        const MLTs = [12, 15.4, 14, 15, 19.18, 32, 34, 45, 47.4, 40.21, 29.32, 42.45, 51.46].map(x => x * 1e-3);
        const hs = [4.2 * 2, 4.6 * 2, 5.0 * 2, 5.6 * 2, 6.41 * 2, 8.15 * 2, 10.25 * 2, 12.75 * 2, 14.05 * 2, 14.6 * 2, 9.71 * 2, 15.15 * 2, 18.8 * 2].map(x => x * 1e-3 - 4e-3);
        const Vse = lms.map((lm, i) => lm * Acs[i]);

        const lmp = [52.2, 60.4, 69, 78.8, 97.4, 115.4, 154.6, 191.6, 220, 184.2, 127.12, 174.85, 202.9].map(x => x * 1e-3);
        const Acp = Acs;
        const Wap = Was;
        const MLTp = MLTs;
        const hp = hs;
        const Vsp = lmp.map((lm, i) => lm * Acp[i]);

        const Rths = [63.8, 62.5, 76, 60, 41.49, 21.80, 16.87, 11.2, 9.925, 16.40, 22.53, 11.42, 8.572];
        const Rthp = [63.8, 62.5, 76, 60, 36.82, 19.54, 15.12, 10.10, 8.921, 14.63, 20.63, 10.31, 7.674];

        // Main calculation function
        function calculateLosses() {
            // Read input parameters (these are common for all core calculations)
            const Po = parseFloat(document.getElementById('outputPower').value);
            const Vpp = parseFloat(document.getElementById('primaryVoltageParallel').value);
            const Vps = parseFloat(document.getElementById('primaryVoltageSeries').value);
            const f = parseFloat(document.getElementById('frequency').value);
            const Vd = 1.4; // Fixed value from your old code
            const D = parseFloat(document.getElementById('dutyCycle').value);
            const Ploss_max = 20; // Fixed value
            const ds = 0.000812; // Fixed
            const dps = 0.0008; // Fixed
            const dpp = dps;
            const Tamb = 25; // Fixed
            const Tmax = 75; // Fixed

            const selectedCoreIndex = parseInt(document.getElementById('coreType').value);

            // Derived constants (these are common for all core calculations)
            const k = 0.160e3;
            const alpha = 1.078;
            const Beta = 2.92;
            const Vs1 = 24; // Fixed in MATLAB
            const Vs2 = 24; // Fixed in MATLAB
            const ns = 3; // Fixed in MATLAB
            const np = 3; // Fixed in MATLAB

            // Intermediate calculations (common for all core calculations)
            const I24 = Po / 2 / (Vs2 + 2 * Vd);
            const Isrms = ((Vs1 / Vps) * I24 + (Vs2 / Vps) * I24) * Math.sqrt(D);
            const Iprms = ((Vs1 / Vpp) * I24 + (Vs2 / Vpp) * I24) * Math.sqrt(D);
            const I01rms = (1 / 2) * (I24 * Math.sqrt(1 + D));

            const Awps = 2 * Math.PI * (dps / 2)**2;
            const Awpp = 2 * Math.PI * (dpp / 2)**2;
            const Aws = Math.PI * (ds / 2)**2; 

            const rho = 1.724e-8;
            const muc = 1.256629e-6;

            // Calculate wire parameters (these are global and don't depend on core)
            const Sd = Math.sqrt(rho * (1 + 0.0393 * (Tmax - 25)) / (Math.PI * f * muc));
            const nus = (Math.sqrt(Math.PI) * dps) / (2 * (dps + 0.051e-3));
            const nup = (Math.sqrt(Math.PI) * dpp) / (2 * (dpp + 0.051e-3));

            const deltaps = (Math.PI / 4)**0.75 * (dps / Sd) * Math.sqrt(nus);
            const deltapp = (Math.PI / 4)**0.75 * (dpp / Sd) * Math.sqrt(nup);
            const deltas = (Math.PI / 4)**0.75 * (ds / Sd) * Math.sqrt(nup); 

            const Skeffs = (Math.sinh(2 * deltaps) + Math.sin(2 * deltaps)) / (Math.cosh(2 * deltaps) - Math.cos(2 * deltaps));
            const Skeffp = (Math.sinh(2 * deltapp) + Math.sin(2 * deltapp)) / (Math.cosh(2 * deltapp) + Math.cos(2 * deltapp));
            const Proxeffs = (Math.sinh(deltaps) - Math.sin(deltaps)) / (Math.cosh(deltaps) + Math.cos(deltaps));
            const Proxeffp = (Math.sinh(deltapp) - Math.sin(deltapp)) / (Math.cosh(deltapp) + Math.cos(deltapp));

            // Initialize a structure to hold results for all cores for the summary table
            const allCoresLossSummary = [];

            // Initialize results for the currently selected core (for plotting)
            const selectedCoreResults = {
                selectedCoreIndex: selectedCoreIndex,
                Turns: { Series: { Primary: [], Secondary: [] }, Parallel: { Primary: [], Secondary: [] } },
                Flux: { Series: [], Parallel: [] },
                Pfes: [], Pfep: [],
                Layers: { Series: { Primary: [], Secondary: [] }, Parallel: { Primary: [], Secondary: [] } },
                Lfactor: { Series: { Primary: [], Secondary: [] }, Parallel: { Primary: [], Secondary: [] } },
                Fr: { Series: { Primary: [], Secondary: [] }, Parallel: { Primary: [], Secondary: [] } },
                Resistance: { Series: { Primary: [], Secondary: [] }, Parallel: { Primary: [], Secondary: [] } },
                CopperLoss: { Series: [], Parallel: [] },
                PowerLoss: { Series: [], Parallel: [] },
                FillFactor: { Series: [] },
                Ku: { Series: [] },
                Optimal: {
                    Series: { Power: NaN, B: NaN, Np: NaN },
                    Parallel: { Power: NaN, B: NaN, Np: NaN }
                },
                Pmaxs: NaN,
                Pmaxp: NaN
            };

            // Loop through all cores to calculate summary data
            for (let i = 0; i < num_cores; i++) {
                const current_lms = lms[i];
                const current_Acs = Acs[i];
                const current_Was = Was[i];
                const current_MLTs = MLTs[i];
                const current_hs = hs[i];
                const current_Vse = Vse[i];

                const current_lmp = lmp[i];
                const current_Acp = Acp[i];
                const current_Wap = Wap[i];
                const current_MLTp = MLTp[i];
                const current_hp = hp[i];
                const current_Vsp = Vsp[i];

                const current_Rths = Rths[i];
                const current_Rthp = Rthp[i];

                const Pmax_series_core = (Tmax - Tamb) / current_Rths;
                const Pmax_parallel_core = (Tmax - Tamb) / current_Rthp;

                const Bsmax_core = (Pmax_series_core / (k * f**alpha * current_Vse))**(1/Beta);
                const Bpmax_core = (Pmax_parallel_core / (k * f**alpha * current_Vsp))**(1/Beta);

                const Npsmax_core = (0.78 * current_Was) / (Awps + Aws / ns);
                const Nppmax_core = (0.78 * current_Wap) / (Awpp + Aws / np);

                // Calculate turns ranges for current core
                let Nps_range_core = [];
                const Nps_min_core = Math.ceil((0.5 * Vps * D) / (2 * current_Acs * f * Bsmax_core));
                for (let n = Nps_min_core; n <= Npsmax_core; n++) { Nps_range_core.push(n); }

                let Npp_range_core = [];
                const Npp_min_core = Math.ceil((Vpp * D) / (2 * current_Acp * f * Bpmax_core));
                for (let n = Npp_min_core; n <= Nppmax_core; n++) { Npp_range_core.push(n); }

                const B_series_full_core = Nps_range_core.map(Np => (0.5 * Vps * D) / (2 * current_Acs * f * Np));
                const B_parallel_full_core = Npp_range_core.map(Np => (Vpp * D) / (2 * current_Acp * f * Np));

                const valid_idx_series_core = B_series_full_core.map(B => B <= Bsmax_core);
                const valid_idx_parallel_core = B_parallel_full_core.map(B => B <= Bpmax_core);

                const B_series_core = B_series_full_core.filter((_, idx) => valid_idx_series_core[idx]);
                const B_parallel_core = B_parallel_full_core.filter((_, idx) => valid_idx_parallel_core[idx]);
                const Nps_valid_core = Nps_range_core.filter((_, idx) => valid_idx_series_core[idx]);
                const Npp_valid_core = Npp_range_core.filter((_, idx) => valid_idx_parallel_core[idx]);

                const Pfes_core = B_series_core.map(B => k * f**alpha * B**Beta * current_Acs * current_lms);
                const Pfep_core = B_parallel_core.map(B => k * f**alpha * B**Beta * current_Acp * current_lmp);

                const Ns_series_core = Nps_valid_core.map(Np => Np / ns);
                const Ns_parallel_core = Npp_valid_core.map(Np => Np / np);

                const Lfactor_series_primary_core = Nps_valid_core.map(Np => (2 * (Math.max((0.5 * Np * dps) / current_hs, 1)**2) - 1) / 3);
                const Lfactor_series_secondary_core = Ns_series_core.map(Ns => (2 * (Math.max((0.5 * Ns * ds) / current_hs, 1)**2) - 1) / 3);
                const Lfactor_parallel_primary_core = Npp_valid_core.map(Np => (2 * (Math.max((0.5 * Np * dpp) / current_hp, 1)**2) - 1) / 3);
                const Lfactor_parallel_secondary_core = Ns_parallel_core.map(Ns => (2 * (Math.max((0.5 * Ns * ds) / current_hp, 1)**2) - 1) / 3);

                const Fr_series_primary_core = Lfactor_series_primary_core.map(Lfactor => deltaps * (Skeffs + Lfactor * Proxeffs));
                const Fr_series_secondary_core = Lfactor_series_secondary_core.map(Lfactor => deltas * (Skeffs + Lfactor * Proxeffs));
                const Fr_parallel_primary_core = Lfactor_parallel_primary_core.map(Lfactor => deltapp * (Skeffp + Lfactor * Proxeffp));
                const Fr_parallel_secondary_core = Lfactor_parallel_secondary_core.map(Lfactor => deltas * (Skeffp + Lfactor * Proxeffp));

                const Resistance_series_primary_core = Fr_series_primary_core.map((Fr, idx) => Fr * Nps_valid_core[idx] * (rho / Awps) * current_MLTs);
                const Resistance_series_secondary_core = Fr_series_secondary_core.map((Fr, idx) => Fr * Ns_series_core[idx] * (rho / Aws) * current_MLTs);
                const Resistance_parallel_primary_core = Fr_parallel_primary_core.map((Fr, idx) => Fr * Npp_valid_core[idx] * (rho / Awpp) * current_MLTp);
                const Resistance_parallel_secondary_core = Fr_parallel_secondary_core.map((Fr, idx) => Fr * Ns_parallel_core[idx] * (rho / Aws) * current_MLTp);

                const CopperLoss_series_core = Resistance_series_primary_core.map((R_p, idx) => R_p * Isrms**2 + Resistance_series_secondary_core[idx] * I01rms**2);
                const CopperLoss_parallel_core = Resistance_parallel_primary_core.map((R_p, idx) => 0.5 * R_p * (0.5 * Iprms)**2 + Resistance_parallel_secondary_core[idx] * I01rms**2);

                const PowerLoss_series_core = CopperLoss_series_core.map((Closs, idx) => Closs + Pfes_core[idx]);
                const PowerLoss_parallel_core = CopperLoss_parallel_core.map((Closs, idx) => Closs + Pfep_core[idx]);

                let optimalSeriesPower = NaN;
                let optimalSeriesNp = NaN;
                if (PowerLoss_series_core && PowerLoss_series_core.length > 0) {
                    let minLossIdx = 0;
                    for (let j = 0; j < PowerLoss_series_core.length; j++) {
                        if (PowerLoss_series_core[j] < PowerLoss_series_core[minLossIdx]) {
                            minLossIdx = j;
                        }
                    }
                    optimalSeriesPower = PowerLoss_series_core[minLossIdx];
                    optimalSeriesNp = Nps_valid_core[minLossIdx];
                }

                let optimalParallelPower = NaN;
                let optimalParallelNp = NaN;
                if (PowerLoss_parallel_core && PowerLoss_parallel_core.length > 0) {
                    let minLossIdx = 0;
                    for (let j = 0; j < PowerLoss_parallel_core.length; j++) {
                        if (PowerLoss_parallel_core[j] < PowerLoss_parallel_core[minLossIdx]) {
                            minLossIdx = j;
                        }
                    }
                    optimalParallelPower = PowerLoss_parallel_core[minLossIdx];
                    optimalParallelNp = Npp_valid_core[minLossIdx];
                }

                allCoresLossSummary.push({
                    coreName: core_names[i],
                    Pmaxs: Pmax_series_core,
                    OptimalSeriesPower: optimalSeriesPower,
                    OptimalSeriesNp: optimalSeriesNp, // Added optimal Np for series
                    Pmaxp: Pmax_parallel_core,
                    OptimalParallelPower: optimalParallelPower,
                    OptimalParallelNp: optimalParallelNp // Added optimal Np for parallel
                });

                // If this is the selected core, populate selectedCoreResults for plotting
                if (i === selectedCoreIndex) {
                    selectedCoreResults.Turns.Series.Primary = Nps_valid_core;
                    selectedCoreResults.Turns.Parallel.Primary = Npp_valid_core;
                    selectedCoreResults.Flux.Series = B_series_core;
                    selectedCoreResults.Flux.Parallel = B_parallel_core;
                    selectedCoreResults.Pfes = Pfes_core;
                    selectedCoreResults.Pfep = Pfep_core;
                    
                    selectedCoreResults.Turns.Series.Secondary = Ns_series_core;
                    selectedCoreResults.Turns.Parallel.Secondary = Ns_parallel_core;

                    selectedCoreResults.Layers.Series.Primary = Nps_valid_core.map(Np => Math.max((0.5 * Np * dps) / current_hs, 1));
                    selectedCoreResults.Layers.Series.Secondary = Ns_series_core.map(Ns => Math.max((0.5 * Ns * ds) / current_hs, 1));
                    selectedCoreResults.Layers.Parallel.Primary = Npp_valid_core.map(Np => Math.max((0.5 * Np * dpp) / current_hp, 1));
                    selectedCoreResults.Layers.Parallel.Secondary = Ns_parallel_core.map(Ns => Math.max((0.5 * Ns * ds) / current_hp, 1));

                    selectedCoreResults.Lfactor.Series.Primary = Lfactor_series_primary_core;
                    selectedCoreResults.Lfactor.Series.Secondary = Lfactor_series_secondary_core;
                    selectedCoreResults.Lfactor.Parallel.Primary = Lfactor_parallel_primary_core;
                    selectedCoreResults.Lfactor.Parallel.Secondary = Lfactor_parallel_secondary_core;

                    selectedCoreResults.Fr.Series.Primary = Fr_series_primary_core;
                    selectedCoreResults.Fr.Series.Secondary = Fr_series_secondary_core;
                    selectedCoreResults.Fr.Parallel.Primary = Fr_parallel_primary_core;
                    selectedCoreResults.Fr.Parallel.Secondary = Fr_parallel_secondary_core;

                    selectedCoreResults.Resistance.Series.Primary = Resistance_series_primary_core;
                    selectedCoreResults.Resistance.Series.Secondary = Resistance_series_secondary_core;
                    selectedCoreResults.Resistance.Parallel.Primary = Resistance_parallel_primary_core;
                    selectedCoreResults.Resistance.Parallel.Secondary = Resistance_parallel_secondary_core;

                    selectedCoreResults.CopperLoss.Series = CopperLoss_series_core;
                    selectedCoreResults.CopperLoss.Parallel = CopperLoss_parallel_core;
                    selectedCoreResults.PowerLoss.Series = PowerLoss_series_core;
                    selectedCoreResults.PowerLoss.Parallel = PowerLoss_parallel_core;

                    // Recalculate Ku for the selected core
                    const t_ins = 0.051e-3; // Interlayer insulation thickness (m)
                    const d_barep = 0.4e-3;
                    const d_insulatedp = 0.442e-3;
                    const A_copperp = 2 * Math.PI * (d_barep / 2)**2; 
                    const A_total_wirep = Math.PI * (d_insulatedp / 2)**2;
                    const d_bares = 0.812e-3;
                    const d_insulateds = 1.082e-3;
                    const A_coppers = Math.PI * (d_bares / 2)**2;
                    const A_total_wires = Math.PI * (d_insulateds / 2)**2;
                    const A_total_wire = A_total_wirep + A_total_wires;
                    const S1 = (A_copperp + A_coppers) / A_total_wire;

                    selectedCoreResults.FillFactor.Series = [];
                    selectedCoreResults.Ku.Series = [];

                    const h = current_hs;
                    const margin = 1.5e-3;
                    const top_clearance = 1e-3;
                    const bottom_clearance = 1e-3;
                    const usable_width = current_Was / h;
                    const usable_width_eff = usable_width - margin;
                    const usable_height_eff = h - top_clearance - bottom_clearance;
                    const A_usable_window = usable_width_eff * usable_height_eff;
                    const S3 = (usable_width_eff * usable_height_eff) / (usable_width * h);

                    for (let j = 0; j < Nps_valid_core.length; j++) {
                        const Np = Nps_valid_core[j];
                        const Ns = Ns_series_core[j];
                        const Nlp = selectedCoreResults.Layers.Series.Primary[j];
                        const Nls = selectedCoreResults.Layers.Series.Secondary[j];

                        const Awp_total = Np * Awps;
                        const Aws_total = Ns * Aws;
                        const A_copper_total = Awp_total + Aws_total;

                        const A_allocated = current_Was - (current_Was - A_copper_total);
                        const S2_dynamic = A_copper_total / A_allocated;
                        const layer_penalty = 1 - 0.02 * (Nlp + Nls - 1);
                   D`
                        const S2 = Math.max(Math.min(S2_dynamic * layer_penalty, 1), 0);

                        const A_ins = (Nlp + Nls - 1) * t_ins * h;
                        const S4 = A_usable_window / (A_usable_window + A_ins);

                        const ku_dynamic = S1 * S2 * S3 * S4;
                        selectedCoreResults.Ku.Series.push(ku_dynamic);
                        selectedCoreResults.FillFactor.Series.push(ku_dynamic);
                    }

                    // Optimal points calculation for selected core
                    selectedCoreResults.Optimal.Series.Power = optimalSeriesPower;
                    selectedCoreResults.Optimal.Series.Np = optimalSeriesNp;
                    selectedCoreResults.Optimal.Parallel.Power = optimalParallelPower;
                    selectedCoreResults.Optimal.Parallel.Np = optimalParallelNp;
                    
                    if (selectedCoreResults.PowerLoss.Series && selectedCoreResults.PowerLoss.Series.length > 0) {
                        let minLossIdx = 0;
                        for (let j = 0; j < selectedCoreResults.PowerLoss.Series.length; j++) {
                            if (selectedCoreResults.PowerLoss.Series[j] < selectedCoreResults.PowerLoss.Series[minLossIdx]) {
                                minLossIdx = j;
                            }
                        }
                        selectedCoreResults.Optimal.Series.B = selectedCoreResults.Flux.Series[minLossIdx];
                    } else {
                        selectedCoreResults.Optimal.Series.B = NaN;
                    }

                    if (selectedCoreResults.PowerLoss.Parallel && selectedCoreResults.PowerLoss.Parallel.length > 0) {
                        let minLossIdx = 0;
                        for (let j = 0; j < selectedCoreResults.PowerLoss.Parallel.length; j++) {
                            if (selectedCoreResults.PowerLoss.Parallel[j] < selectedCoreResults.PowerLoss.Parallel[minLossIdx]) {
                                minLossIdx = j;
                            }
                        }
                        selectedCoreResults.Optimal.Parallel.B = selectedCoreResults.Flux.Parallel[minLossIdx];
                    } else {
                        selectedCoreResults.Optimal.Parallel.B = NaN;
                    }

                    selectedCoreResults.Pmaxs = Pmax_series_core;
                    selectedCoreResults.Pmaxp = Pmax_parallel_core;
                }
            }

            return { selectedCoreResults, allCoresLossSummary };
        }

        function plotLossVsTurns(data, plotDivId) { /* ... ADD DARK THEME LAYOUT ... */ }
        function plotFluxVsTurns(data, plotDivId) { /* ... ADD DARK THEME LAYOUT ... */ }
        function plotCompareCoreLosses(allCoresSummary, plotDivId, Ploss_max) { /* ... ADD DARK THEME LAYOUT ... */ }
		// ...and so on for all plot functions.

        document.getElementById('calculateButton').addEventListener('click', () => {
            const plotDiv = document.getElementById('plotDiv');
            const loadingOverlay = document.getElementById('loadingOverlay');
            loadingOverlay.classList.remove('hidden');
            Plotly.purge(plotDiv);

            setTimeout(() => {
                try {
                    const { selectedCoreResults, allCoresLossSummary } = calculateLosses();
                    const plotType = document.getElementById('plotType').value;
                    // For brevity, I'll just show one case. You'd fill this out.
					switch (plotType) {
						case 'loss_vs_flux':
							plotLossVsFlux(selectedCoreResults, 'plotDiv');
							break;
						// ... other cases
						default:
							plotTotalPowerLossVsTurnsCombined(selectedCoreResults, 'plotDiv'); // Default plot
					}
                    updateLossDiffTable(allCoresLossSummary);
                } catch (error) {
                    console.error("Error during calculation or plotting:", error);
                    plotDiv.innerHTML = `<p class="text-red-400">Error: ${error.message}. Check console.</p>`;
                } finally {
                    loadingOverlay.classList.add('hidden');
                }
            }, 50);
        });

        document.addEventListener('DOMContentLoaded', () => {
            const coreTypeSelect = document.getElementById('coreType');
            core_names.forEach((name, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = name;
                coreTypeSelect.appendChild(option);
            });
            document.getElementById('calculateButton').click();
        });
	</script>
</body>
</html>
