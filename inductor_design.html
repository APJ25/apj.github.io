<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Inductor Design Analysis</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
            color: #334155;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }
        .input-group {
            display: flex;
            flex-direction: column;
            margin-bottom: 1rem;
        }
        .input-group label {
            margin-bottom: 0.5rem;
            font-weight: 600;
        }
        .input-group input, .input-group select {
            padding: 0.75rem;
            border: 1px solid #cbd5e1;
            border-radius: 0.5rem;
            font-size: 1rem;
            background-color: #ffffff;
            transition: border-color 0.2s;
        }
        .input-group input:focus, .input-group select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.25);
        }
        .btn {
            padding: 0.75rem 1.5rem;
            background-color: #3b82f6;
            color: white;
            border-radius: 0.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            border: none;
        }
        .btn:hover {
            background-color: #2563eb;
            transform: translateY(-1px);
        }
        .btn:active {
            transform: translateY(0);
        }
        .plot-container {
            background-color: #ffffff;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
            margin-top: 2rem;
            min-height: 400px; /* Ensure plot div has height */
            display: flex;
            flex-direction: column; /* Allow content to stack */
            justify-content: center;
            align-items: center;
            position: relative; /* For loading indicator */
        }
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10;
            border-radius: 0.75rem;
        }
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #3b82f6;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 2rem;
            background-color: #ffffff;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            overflow: hidden; /* For rounded corners on table */
        }
        th, td {
            padding: 1rem;
            text-align: left;
            border-bottom: 1px solid #e2e8f0;
        }
        th {
            background-color: #f8fafc;
            font-weight: 600;
            color: #475569;
        }
        tr:last-child td {
            border-bottom: none;
        }
        tr:hover {
            background-color: #f0f4f8;
        }

        .explanation-section {
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid #e2e8f0;
        }
        .explanation-section:last-of-type {
            border-bottom: none;
        }
        .explanation-section h2 {
            font-size: 2rem;
            font-weight: 700;
            color: #1e293b;
            margin-bottom: 1rem;
            text-align: center;
        }
        .explanation-section h3 {
            font-size: 1.5rem;
            font-weight: 600;
            color: #334155;
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
        }
        .explanation-section p {
            margin-bottom: 1rem;
            line-height: 1.7;
        }
        .equation-block {
            background-color: #f8fafc;
            border-left: 4px solid #3b82f6;
            padding: 1.25rem;
            margin: 1.5rem 0;
            border-radius: 0.5rem;
            font-family: 'Fira Code', 'Cascadia Code', monospace;
            font-size: 1.05rem;
            overflow-x: auto;
        }
        .equation-block .katex-display {
            margin: 0 !important;
        }
        .plot-description {
            text-align: center;
            font-style: italic;
            font-size: 0.95rem;
            color: #64748b;
            margin-top: 0.5rem;
            margin-bottom: 1rem;
        }
        .back-button-container {
            display: flex;
            justify-content: center;
            margin-top: 3rem;
        }
        .back-to-portfolio-btn {
            background-color: #6c757d;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            color: white;
            text-decoration: none;
            font-weight: 600;
            transition: background-color 0.2s, transform 0.1s;
        }
        .back-to-portfolio-btn:hover {
            background-color: #5a6268;
            transform: translateY(-2px);
        }
        /* Specific style for Plotly graph div within plot-container */
        #plot-area {
            width: 100%;
            height: 100%;
            min-height: 350px; /* Ensure Plotly takes up space */
            flex-grow: 1; /* Allow it to grow */
        }
    </style>
</head>
<body class="p-4">
    <div class="container bg-white rounded-xl shadow-lg p-6 md:p-8">
        <h1 class="text-3xl font-bold text-center text-gray-800 mb-6">Inductor Design Analysis</h1>

        <div class="explanation-section">
            <h2>Introduction to Inductor Design</h2>
            <p>Inductors are crucial components in power electronic converters, used for energy storage, filtering, and current ripple reduction. Unlike transformers, inductors primarily store energy in their magnetic field. Their design involves carefully balancing inductance requirements, DC current handling, ripple current, and thermal considerations. This section outlines the principles and calculations for designing a power inductor, enabling you to select an appropriate core and winding configuration for your application.</p>
            <p>A well-designed inductor minimizes losses, avoids saturation under peak current conditions, and fits within the available physical space.</p>
        </div>

        <div class="explanation-section">
            <h2>Core Selection and Material Properties</h2>
            <p>For inductors, core material selection is critical, particularly concerning saturation flux density ($B_{sat}$), permeability ($\mu_r$), and core losses at the operating frequency and flux swing. Air gaps are often introduced in inductor cores to increase the effective magnetic path length, reduce the effective permeability, and thereby prevent saturation and store more energy without saturating the core prematurely. Common core types for inductors include E-cores, Toroids, and Pot cores, often made from ferrites or powdered iron materials.</p>
            <p>Key parameters for inductor core selection:</p>
            <ul>
                <li><strong>Effective Area ($A_e$)</strong>: The cross-sectional area through which the magnetic flux passes.</li>
                <li><strong>Effective Magnetic Path Length ($l_e$)</strong>: The average length of the magnetic flux path.</li>
                <li><strong>Window Area ($W_a$)</strong>: The area available for winding turns.</li>
                <li><strong>Mean Length Per Turn (MLT)</strong>: The average length of a single winding turn.</li>
                <li><strong>Gap Length ($l_g$)</strong>: The length of the air gap, crucial for controlling inductance and preventing saturation.</li>
            </ul>
        </div>

        <div class="explanation-section">
            <h2>Fundamental Design Equations</h2>
            <p>Inductor design relies on fundamental electromagnetic principles to relate inductance, number of turns, core properties, and current handling capabilities.</p>

            <h3>Inductance and Number of Turns:</h3>
            <p>The inductance ($L$) of a gapped core inductor is given by:</p>
            <div class="equation-block">
                $$
                L = \frac{N^2}{\Re} = \frac{N^2 \cdot \mu_0 \cdot \mu_e \cdot A_e}{l_e} \approx \frac{N^2 \cdot \mu_0 \cdot A_e}{l_e / \mu_r + l_g}
                $$
                Where: <br>
                $N$ is the number of turns.<br>
                $\Re$ is the reluctance of the magnetic circuit.<br>
                $\mu_0$ is the permeability of free space ($4\pi \times 10^{-7}$ H/m).<br>
                $\mu_e$ is the effective permeability of the gapped core.<br>
                $A_e$ is the effective cross-sectional area of the core.<br>
                $l_e$ is the effective magnetic path length.<br>
                $l_g$ is the air gap length.<br>
                $\mu_r$ is the relative permeability of the core material.
            </div>
            <p>From this, the number of turns can be derived:</p>
            <div class="equation-block">
                $$
                N = \sqrt{\frac{L \cdot (l_e / \mu_r + l_g)}{\mu_0 \cdot A_e}}
                $$
            </div>

            <h3>Area Product ($A_p$) Method:</h3>
            <p>The Area Product ($A_p$) is a useful metric for initial core selection. It combines the core's magnetic and winding capabilities:</p>
            <div class="equation-block">
                $$
                A_p = A_e \cdot W_a = \left( \frac{L \cdot I_{pk}^2}{B_{max} \cdot K_u \cdot J_{max}} \right)
                $$
                Where: <br>
                $I_{pk}$ is the peak current through the inductor.<br>
                $B_{max}$ is the maximum allowable flux density (usually $B_{sat}$ or less).<br>
                $K_u$ is the winding utilization factor (typically 0.2 to 0.4 for inductors).<br>
                $J_{max}$ is the maximum allowable current density in the winding wire.
            </div>

            <h3>Peak Flux Density:</h3>
            <p>The peak flux density in the core is crucial to avoid saturation:</p>
            <div class="equation-block">
                $$
                B_{pk} = \frac{L \cdot I_{pk}}{N \cdot A_e}
                $$
            </div>

            <h3>Core Loss (Inductor):</h3>
            <p>Core losses in inductors also follow the Steinmetz equation, but the flux density swing ($\Delta B$) is typically due to the ripple current ($\Delta I$).</p>
            <div class="equation-block">
                $$
                \Delta B = \frac{L \cdot \Delta I}{N \cdot A_e}
                $$
                $$
                P_{core} = k \cdot f^{\alpha} \cdot (\Delta B)^{\beta} \cdot V_e
                $$
            </div>

            <h3>Copper Loss (Inductor):</h3>
            <p>Similar to transformers, copper losses depend on the RMS current ($I_{rms}$) and the AC resistance of the winding ($R_{ac}$), which is affected by skin and proximity effects.</p>
            <div class="equation-block">
                $$
                P_{copper} = I_{rms}^2 \cdot R_{ac} = I_{rms}^2 \cdot F_R \cdot R_{dc}
                $$
            </div>

            <h3>Total Power Loss and Temperature Rise:</h3>
            <p>The total loss and temperature rise calculation mirrors that of the transformer, using the core's thermal resistance.</p>
            <div class="equation-block">
                $$
                P_{total\_loss} = P_{core} + P_{copper}
                $$
                $$
                \Delta T = P_{total\_loss} \cdot R_{th}
                $$
            </div>
        </div>
        
        <h2 class="text-2xl font-bold text-center text-gray-800 mb-4">Interactive Inductor Design Tool</h2>
        <p class="text-center text-gray-600 mb-6">Adjust the parameters below to design an inductor and view its characteristics.</p>

        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 mb-8">
            <div class="input-group">
                <label for="inductorFrequency">Operating Frequency (f) [Hz]:</label>
                <input type="number" id="inductorFrequency" value="100000" step="1000">
            </div>
            <div class="input-group">
                <label for="inductorCurrent">Current (I) [A]:</label>
                <input type="number" id="inductorCurrent" value="8" step="0.1">
            </div>
            <div class="input-group">
                <label for="inductorPermeability">Relative Permeability ($\mu_r$):</label>
                <input type="number" id="inductorPermeability" value="2000" step="100">
            </div>
            <div class="input-group">
                <label for="inductorTargetL">Target Inductance (L) [H]:</label>
                <input type="number" id="inductorTargetL" value="12.7e-6" step="1e-7">
            </div>
            <div class="input-group">
                <label for="inductorFluxDensity">Magnetic Flux Density (B) [T]:</label>
                <input type="number" id="inductorFluxDensity" value="0.2" step="0.01">
            </div>
            <div class="input-group">
                <label for="inductorWireResistivity">Wire Resistivity ($\rho$) [$\Omega \cdot m$]:</label>
                <input type="number" id="inductorWireResistivity" value="1.72e-8" step="1e-9">
            </div>
            <div class="input-group">
                <label for="inductorCoreDiameterCoarseStart">Core Diameter (Dc_start) [m]:</label>
                <input type="number" id="inductorCoreDiameterCoarseStart" value="4e-3" step="0.5e-3">
            </div>
            <div class="input-group">
                <label for="inductorCoreDiameterCoarseEnd">Core Diameter (Dc_end) [m]:</label>
                <input type="number" id="inductorCoreDiameterCoarseEnd" value="14e-3" step="0.5e-3">
            </div>
            <div class="input-group">
                <label for="inductorNumPoints">Number of Data Points (s):</label>
                <input type="number" id="inductorNumPoints" value="100" step="10">
            </div>
            <div class="input-group">
                <label for="inductorPlotType">Select Plot:</label>
                <select id="inductorPlotType" class="w-full">
                    <option value="N_vs_lg">Air Gap vs. Number of Turns ($l_g$ vs N)</option>
                    <option value="A_vs_lg">Air Gap vs. Core Cross-sectional Area ($l_g$ vs A)</option>
                    <option value="invN_vs_lg">Air Gap vs. Inverse Number of Turns ($l_g$ vs 1/N)</option>
                    <option value="A_vs_N">Number of Turns vs. Core Cross-sectional Area (N vs A)</option>
                    <option value="P_vs_Vc">Total Loss vs. Core Volume (P vs $V_c$) with Optimal Point</option>
                    <option value="N_vs_Vc">Turns vs. Core Volume (N vs $V_c$) with Optimal Point</option>
                    <option value="A_vs_L">Inductance vs. Core Cross-sectional Area (L vs A)</option>
                    <option value="A_vs_B">Magnetic Flux Density vs. Core Cross-sectional Area (B vs A)</option>
                    <option value="Energy_vs_A">Electromagnetic Energy ($E_m$, $E_L$) vs. Core Cross-sectional Area (A)</option>
                    <option value="Loss_vs_N_A">Total Loss vs. N and A</option>
                    <option value="Volume_vs_N_A">Core Volume vs. N and A</option>
                    <option value="Aw_vs_N">Window Area vs. Number of Turns ($A_w$ vs N)</option>
                    <option value="Dc_vs_N">Core Diameter vs. Number of Turns ($D_c$ vs N)</option>
                    <option value="L_vs_lg">Inductance vs. Air Gap (L vs $l_g$)</option>
                    <option value="L_vs_Dc">Inductance vs. Core Diameter (L vs $D_c$)</option>
                </select>
            </div>
        </div>
        
        <div class="flex justify-center mb-8">
            <button id="calculateInductorButton" class="btn">Calculate and Plot Inductor</button>
        </div>

        <div id="inductorPlotContainer" class="plot-container">
            <div class="loading-overlay hidden" id="inductorLoadingOverlay">
                <div class="spinner"></div>
            </div>
            <div id="plot-area" style="min-height: 350px;"></div>
            <p id="inductorPlotDescription" class="plot-description"></p>
        </div>

        <div id="inductorDesignSummaryContainer" class="mt-8">
            <h2 class="text-2xl font-bold text-center text-gray-800 mb-4">Inductor Design Summary (at N=12 Turns)</h2>
            <div id="inductorDesignSummary" class="overflow-x-auto">
                <table class="min-w-full divide-y divide-gray-200">
                    <thead class="bg-gray-50">
                        <tr>
                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Parameter</th>
                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Value</th>
                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Unit</th>
                        </tr>
                    </thead>
                    <tbody class="bg-white divide-y divide-gray-200" id="inductorSummaryTableBody">
                        <tr><td>Air Gap ($l_g$)</td><td id="output_inductor_air_gap">N/A</td><td>mm</td></tr>
                        <tr><td>Number of Turns (N)</td><td id="output_inductor_num_turns">N/A</td><td></td></tr>
                        <tr><td>Core Cross-sectional Area (A)</td><td id="output_inductor_area">N/A</td><td>mm²</td></tr>
                        <tr><td>Window Area ($A_w$)</td><td id="output_inductor_aw">N/A</td><td>mm²</td></tr>
                        <tr><td>Core Diameter ($D_c$)</td><td id="output_inductor_dc">N/A</td><td>mm</td></tr>
                        <tr><td>Inductance ($L_1$)</td><td id="output_inductor_L1">N/A</td><td>μH</td></tr>
                        <tr><td>Core Volume ($V_c$)</td><td id="output_inductor_Vc">N/A</td><td>cm³</td></tr>
                        <tr><td>Core Loss ($P_{core}$)</td><td id="output_inductor_Pin">N/A</td><td>W</td></tr>
                        <tr><td>Copper Loss ($P_w$)</td><td id="output_inductor_Pw">N/A</td><td>W</td></tr>
                        <tr><td>Total Loss (P)</td><td id="output_inductor_P_total">N/A</td><td>W</td></tr>
                    </tbody>
                </table>
                <p class="text-center text-sm text-gray-600 mt-4"><em>Note: The core is R22/6/6 with an air gap of 0.867mm (as per original MATLAB comment, though calculated value may vary).</em></p>
            </div>
        </div>

        <div class="back-button-container">
            <a href="master_thesis_details.html" class="back-to-portfolio-btn">← Back to Thesis Details</a>
        </div>
    </div>

    <script>
        // Constants from MATLAB code
        const uo = 4 * Math.PI * 1e-7; // Permeability of free space
        const lc = 0e-3; // Core length (from MATLAB, seems to be 0)

        // Steinmetz parameters (from MATLAB)
        const a1 = -0.1108;
        const b1 = 0.2134;
        const c1 = 4.213;
        const a2 = 0.215;
        const b2 = 0.1373;
        const c2 = 0.03359;
        const a3 = 1.022e+06;
        const b3 = -1.348;
        const c3 = -0.02106;

        let inductorResults = null; // To store calculated results for plotting

        // Function to perform inductor design calculations
        function calculateInductorDesign() {
            // Show loading overlay
            document.getElementById('inductorLoadingOverlay').classList.remove('hidden');
            // Clear previous plot and description area
            document.getElementById('plot-area').innerHTML = ''; 
            document.getElementById('inductorPlotDescription').textContent = '';

            // Read input values
            const f = parseFloat(document.getElementById('inductorFrequency').value);
            const I = parseFloat(document.getElementById('inductorCurrent').value);
            const ur = parseFloat(document.getElementById('inductorPermeability').value);
            const L_target = parseFloat(document.getElementById('inductorTargetL').value);
            const B_target = parseFloat(document.getElementById('inductorFluxDensity').value);
            const rau = parseFloat(document.getElementById('inductorWireResistivity').value);
            const Dc_coarse_start = parseFloat(document.getElementById('inductorCoreDiameterCoarseStart').value);
            const Dc_coarse_end = parseFloat(document.getElementById('inductorCoreDiameterCoarseEnd').value);
            const s = parseInt(document.getElementById('inductorNumPoints').value);

            // Calculate Steinmetz coefficients based on frequency
            const alpha = (a2 * Math.pow(f, b2) + c2);
            const Beta = (a1 * Math.pow(f, b1) + c1);
            const k = a3 * Math.pow(f, b3) + c3;

            // Generate Dc values (linear interpolation)
            const Dc = [];
            for (let i = 0; i < s; i++) {
                const ratio = i / (s - 1);
                Dc.push(Dc_coarse_start + ratio * (Dc_coarse_end - Dc_coarse_start));
            }

            // Preallocate arrays
            const valueOfeg = new Array(s);
            const valueOfN = new Array(s);
            const A = new Array(s);
            const L1 = new Array(s);
            const Ee = new Array(s);
            const B1 = new Array(s);
            const Em = new Array(s);
            const Vc = new Array(s);
            const Bac = new Array(s);
            const Pin = new Array(s);
            const Pw = new Array(s);
            const P = new Array(s);
            const Aw = new Array(s);
            const Le = new Array(s);
            const lm = new Array(s);
            const DCR = new Array(s);

            const Sp = I / 4.5 * 1e-6; // Defined outside loop, as per MATLAB logic

            for (let i = 0; i < s; i++) {
                // Step 1: Calculate core area
                A[i] = Math.PI * Dc[i]**2 / 4;

                // Step 2: Calculate N and eg based on simplified equations
                // Checks for division by zero before calculating N and eg
                if (A[i] === 0 || B_target === 0 || L_target === 0 || I === 0) {
                    valueOfN[i] = NaN;
                    valueOfeg[i] = NaN;
                } else {
                    valueOfN[i] = (L_target * I) / (A[i] * B_target);
                    valueOfeg[i] = (uo * L_target * I**2) / (A[i] * B_target**2);
                }

                // Initial robust check for NaN/Infinity/negative values immediately after N and eg
                if (!Number.isFinite(valueOfN[i]) || !Number.isFinite(valueOfeg[i]) || valueOfN[i] < 0 || valueOfeg[i] < 0) {
                    // Set all results for this point to NaN so it's filtered out later
                    valueOfN[i] = NaN; valueOfeg[i] = NaN; A[i] = NaN; L1[i] = NaN;
                    Ee[i] = NaN; B1[i] = NaN; Em[i] = NaN; Vc[i] = NaN;
                    Bac[i] = NaN; Pin[i] = NaN; Pw[i] = NaN; P[i] = NaN;
                    Aw[i] = NaN; Le[i] = NaN; lm[i] = NaN; DCR[i] = NaN;
                    continue; // Skip remaining calculations for this iteration
                }

                // Step 3: Calculate Aw (Window Area)
                Aw[i] = valueOfN[i] * (I / 4.5 * 1e-6) / 0.78;
                if (!Number.isFinite(Aw[i]) || Aw[i] < 0) Aw[i] = NaN;

                // Step 4: Calculate Le (Effective Length of Winding)
                let sqrt_term = 4 * Aw[i] / (0.78 * Math.PI);
                if (sqrt_term < 0 || isNaN(sqrt_term)) sqrt_term = 0; // Handle negative or NaN for sqrt input
                Le[i] = Math.PI * (Math.sqrt(sqrt_term) + (Dc[i] / 2));
                if (!Number.isFinite(Le[i])) Le[i] = NaN;

                // Step 5: Calculate DCR (DC Resistance)
                lm[i] = valueOfN[i] * Math.PI * Dc[i];
                if (Sp === 0) DCR[i] = NaN; // Prevent Infinity if Sp is zero
                else DCR[i] = rau * lm[i] / Sp;
                if (!Number.isFinite(DCR[i])) DCR[i] = NaN;

                // Step 6: Recalculate L1 (actual Inductance with calculated eg)
                const L1_denom = (Le[i] + ur * valueOfeg[i]);
                if (L1_denom === 0) L1[i] = NaN; // Prevent Infinity
                else L1[i] = (uo * ur * valueOfN[i]**2 * A[i]) / L1_denom;
                if (!Number.isFinite(L1[i])) L1[i] = NaN;

                // Step 7: Calculate B1 (Actual Flux Density)
                const B1_denom = (valueOfN[i] * A[i]);
                if (B1_denom === 0) B1[i] = NaN; // Prevent Infinity
                else B1[i] = (L1[i] * I) / B1_denom;
                if (!Number.isFinite(B1[i])) B1[i] = NaN;

                // Step 8: Calculate Energies Ee, Em and Core Volume Vc
                Ee[i] = 1e6 * 0.5 * L1[i] * I**2;
                Em[i] = 1e6 * 0.5 * B1[i]**2 * A[i] * valueOfeg[i] / uo;
                Vc[i] = Le[i] * A[i] * 1e6;
                if (!Number.isFinite(Ee[i])) Ee[i] = NaN;
                if (!Number.isFinite(Em[i])) Em[i] = NaN;
                if (!Number.isFinite(Vc[i])) Vc[i] = NaN;

                // Step 9: Calculate Core Loss (Pin)
                Bac[i] = B1[i] * 0.2;
                if (Bac[i] < 0 || isNaN(Bac[i])) Bac[i] = 0; // Prevent Math.pow(negative, non-integer) or Math.pow(NaN, ...)
                
                // Ensure k, f, alpha, Beta are valid and finite for Pin calculation
                if (!Number.isFinite(k) || !Number.isFinite(f) || !Number.isFinite(alpha) || !Number.isFinite(Beta) || !Number.isFinite(Vc[i])) {
                    Pin[i] = NaN;
                } else {
                    Pin[i] = 1000 * k * Math.pow(f, alpha) * Math.pow(Bac[i], Beta) * Vc[i] * 1e-6;
                }
                if (!Number.isFinite(Pin[i])) Pin[i] = NaN;

                // Step 10: Calculate Copper Loss (Pw) and Total Loss (P)
                Pw[i] = DCR[i] * I**2;
                P[i] = Pw[i] + Pin[i];
                if (!Number.isFinite(Pw[i])) Pw[i] = NaN;
                if (!Number.isFinite(P[i])) P[i] = NaN;
            }

            // Filter out NaN values for plotting and calculations
            const filteredData = [];
            for(let i = 0; i < s; i++) {
                // Only include points where all core derived values are finite numbers
                if (Number.isFinite(valueOfN[i]) && Number.isFinite(valueOfeg[i]) && Number.isFinite(A[i]) && 
                    Number.isFinite(L1[i]) && Number.isFinite(Ee[i]) && Number.isFinite(B1[i]) && 
                    Number.isFinite(Em[i]) && Number.isFinite(Vc[i]) && Number.isFinite(Bac[i]) && 
                    Number.isFinite(Pin[i]) && Number.isFinite(Pw[i]) && Number.isFinite(P[i]) && Number.isFinite(Aw[i])) {
                    filteredData.push({
                        Dc: Dc[i],
                        valueOfeg: valueOfeg[i],
                        valueOfN: valueOfN[i],
                        A: A[i],
                        L1: L1[i],
                        Ee: Ee[i],
                        B1: B1[i],
                        Em: Em[i],
                        Vc: Vc[i],
                        Bac: Bac[i],
                        Pin: Pin[i],
                        Pw: Pw[i],
                        P: P[i],
                        Aw: Aw[i]
                    });
                }
            }

            // Recalculate arrays from filtered data
            const finalDc = filteredData.map(d => d.Dc);
            const finalValueOfeg = filteredData.map(d => d.valueOfeg);
            const finalValueOfN = filteredData.map(d => d.valueOfN);
            const finalA = filteredData.map(d => d.A);
            const finalL1 = filteredData.map(d => d.L1);
            const finalEe = filteredData.map(d => d.Ee);
            const finalB1 = filteredData.map(d => d.B1);
            const finalEm = filteredData.map(d => d.Em);
            const finalVc = filteredData.map(d => d.Vc);
            const finalBac = filteredData.map(d => d.Bac);
            const finalPin = filteredData.map(d => d.Pin);
            const finalPw = filteredData.map(d => d.Pw);
            const finalP = filteredData.map(d => d.P);
            const finalAw = filteredData.map(d => d.Aw);

            // === Normalize values ===
            // Ensure arrays are not empty before min/max calculations to prevent errors
            const P_min = finalP.length > 0 ? Math.min(...finalP) : 0;
            const P_max = finalP.length > 0 ? Math.max(...finalP) : 0;
            const P_range = P_max - P_min;
            const P_norm = P_range > 0 ? finalP.map(val => (val - P_min) / P_range) : finalP.map(() => 0); // Handle zero range

            const Vc_min = finalVc.length > 0 ? Math.min(...finalVc) : 0;
            const Vc_max = finalVc.length > 0 ? Math.max(...finalVc) : 0;
            const Vc_range = Vc_max - Vc_min;
            const Vc_norm = Vc_range > 0 ? finalVc.map(val => (val - Vc_min) / Vc_range) : finalVc.map(() => 0); // Handle zero range


            // === Find intersection point for P vs Vc ===
            let idx_maxVc = -1, idx_minVc = -1;
            if (finalVc.length > 0) {
                idx_maxVc = finalVc.indexOf(Math.max(...finalVc));
                idx_minVc = finalVc.indexOf(Math.min(...finalVc));
            }
            
            let x_intersect = NaN, y_intersect = NaN;
            if (P_norm.length > 0 && Vc_norm.length > 0 && idx_maxVc !== -1 && idx_minVc !== -1) {
                x_intersect = P_norm[idx_maxVc];
                y_intersect = Vc_norm[idx_minVc];
            }

            // === Compute closest point ===
            let closest_P = NaN, closest_Vc = NaN, closest_N = NaN;
            if (P_norm.length > 0 && Vc_norm.length > 0 && Number.isFinite(x_intersect) && Number.isFinite(y_intersect)) {
                let min_distance = Infinity;
                let idx_closest = -1;

                for (let i = 0; i < P_norm.length; i++) {
                    if (Number.isFinite(P_norm[i]) && Number.isFinite(Vc_norm[i])) { // Ensure points are valid
                        const dist = Math.sqrt(Math.pow(P_norm[i] - x_intersect, 2) + Math.pow(Vc_norm[i] - y_intersect, 2));
                        if (dist < min_distance) {
                            min_distance = dist;
                            idx_closest = i;
                        }
                    }
                }
                if (idx_closest !== -1) {
                    closest_P = finalP[idx_closest];
                    closest_Vc = finalVc[idx_closest];
                    closest_N = finalValueOfN[idx_closest];
                }
            }

            // === Summary of Key Parameters at N = 12 ===
            let idx_N12 = -1;
            if (finalValueOfN.length > 0) {
                let min_diff = Infinity;
                for (let i = 0; i < finalValueOfN.length; i++) {
                    if (Number.isFinite(finalValueOfN[i])) { // Ensure N is finite
                        const diff = Math.abs(finalValueOfN[i] - 12);
                        if (diff < min_diff) {
                            min_diff = diff;
                            idx_N12 = i;
                        }
                    }
                }
            }

            let summary_at_N12 = {
                Aw_at_N12: NaN,
                Dc_at_N12: NaN,
                eg_at_N12: NaN,
                A_at_N12: NaN,
                L1_at_N12: NaN,
                Vc_at_N12: NaN,
                Pin_at_N12: NaN,
                Pw_at_N12: NaN,
                P_at_N12: NaN,
                N_at_N12: NaN
            };

            if (idx_N12 !== -1) {
                summary_at_N12.Aw_at_N12 = finalAw[idx_N12] * 1e6; // mm^2
                summary_at_N12.Dc_at_N12 = finalDc[idx_N12] * 1e3; // mm
                summary_at_N12.eg_at_N12 = finalValueOfeg[idx_N12] * 1e3; // mm
                summary_at_N12.A_at_N12 = finalA[idx_N12] * 1e6; // mm^2
                summary_at_N12.L1_at_N12 = finalL1[idx_N12] * 1e6; // uH
                summary_at_N12.Vc_at_N12 = finalVc[idx_N12]; // cm^3
                summary_at_N12.Pin_at_N12 = finalPin[idx_N12]; // W
                summary_at_N12.Pw_at_N12 = finalPw[idx_N12]; // W
                summary_at_N12.P_at_N12 = finalP[idx_N12]; // W
                summary_at_N12.N_at_N12 = finalValueOfN[idx_N12]; // N
            }

            // Store results in a global variable for plotting and display
            inductorResults = {
                Dc: finalDc,
                valueOfeg: finalValueOfeg,
                valueOfN: finalValueOfN,
                A: finalA,
                L1: finalL1,
                Ee: finalEe,
                B1: finalB1,
                Em: finalEm,
                Vc: finalVc,
                Bac: finalBac,
                Pin: finalPin,
                Pw: finalPw,
                P: finalP,
                Aw: finalAw,
                closest_P: closest_P,
                closest_Vc: closest_Vc,
                closest_N: closest_N,
                P_norm: P_norm,
                Vc_norm: Vc_norm,
                idx_maxVc: idx_maxVc,
                idx_minVc: idx_minVc,
                summary_at_N12: summary_at_N12,
                L_target: L_target // Pass target L for L vs A plot
            };

            // Update summary table
            updateInductorOutputs(summary_at_N12);

            // Plot the initial selected plot
            plotInductorResults(inductorResults, document.getElementById('inductorPlotType').value);

            // Hide loading overlay
            document.getElementById('inductorLoadingOverlay').classList.add('hidden');
        }

        // Function to update the output summary table
        function updateInductorOutputs(summary) {
            document.getElementById('output_inductor_air_gap').textContent = isNaN(summary.eg_at_N12) ? 'N/A' : summary.eg_at_N12.toFixed(3);
            document.getElementById('output_inductor_num_turns').textContent = isNaN(summary.N_at_N12) ? 'N/A' : summary.N_at_N12.toFixed(2);
            document.getElementById('output_inductor_area').textContent = isNaN(summary.A_at_N12) ? 'N/A' : summary.A_at_N12.toFixed(2);
            document.getElementById('output_inductor_aw').textContent = isNaN(summary.Aw_at_N12) ? 'N/A' : summary.Aw_at_N12.toFixed(2);
            document.getElementById('output_inductor_dc').textContent = isNaN(summary.Dc_at_N12) ? 'N/A' : summary.Dc_at_N12.toFixed(2);
            document.getElementById('output_inductor_L1').textContent = isNaN(summary.L1_at_N12) ? 'N/A' : summary.L1_at_N12.toFixed(2);
            document.getElementById('output_inductor_Vc').textContent = isNaN(summary.Vc_at_N12) ? 'N/A' : summary.Vc_at_N12.toFixed(2);
            document.getElementById('output_inductor_Pin').textContent = isNaN(summary.Pin_at_N12) ? 'N/A' : summary.Pin_at_N12.toFixed(2);
            document.getElementById('output_inductor_Pw').textContent = isNaN(summary.Pw_at_N12) ? 'N/A' : summary.Pw_at_N12.toFixed(2);
            document.getElementById('output_inductor_P_total').textContent = isNaN(summary.P_at_N12) ? 'N/A' : summary.P_at_N12.toFixed(2);
        }

        // Function to plot inductor results
        function plotInductorResults(results, plotType) {
            const plotDiv = document.getElementById('plot-area');
            const descriptionDiv = document.getElementById('inductorPlotDescription');
            let data = [];
            let layout = {};
            let plotDescription = '';

            // If no valid data points, display a message
            if (!results || results.valueOfN.length === 0) {
                plotDiv.innerHTML = '<p class="text-gray-500">No data available for plotting. Please adjust inputs and calculate to generate valid data.</p>';
                descriptionDiv.textContent = '';
                return;
            }

            // Clear previous content
            plotDiv.innerHTML = '';

            switch (plotType) {
                case 'N_vs_lg':
                    data.push({
                        x: results.valueOfN,
                        y: results.valueOfeg.map(val => val * 1000), // mm
                        mode: 'lines',
                        name: 'Air Gap vs. N',
                        line: { color: 'black', dash: 'dash', width: 3 }
                    });
                    layout = {
                        title: 'Air Gap ($l_g$) vs. Number of Turns (N)',
                        xaxis: { title: 'Number of Turns (N)' },
                        yaxis: { title: 'Air Gap ($l_g$) (mm)' }
                    };
                    plotDescription = 'This plot shows the relationship between the calculated air gap and the number of turns. As turns increase, the required air gap generally decreases for a constant inductance.';
                    break;
                case 'A_vs_lg':
                    data.push({
                        x: results.A.map(val => val * 1e6), // mm^2
                        y: results.valueOfeg.map(val => val * 1000), // mm
                        mode: 'lines',
                        name: 'Air Gap vs. Area',
                        line: { color: 'black', dash: 'dash', width: 3 }
                    });
                    layout = {
                        title: 'Air Gap ($l_g$) vs. Core Cross-sectional Area (A)',
                        xaxis: { title: 'Core Cross-sectional Area (A) (mm²)' },
                        yaxis: { title: 'Air Gap ($l_g$) (mm)' }
                    };
                    plotDescription = 'This plot illustrates how the air gap changes with the core cross-sectional area. A larger core area generally requires a smaller air gap for the same inductance.';
                    break;
                case 'invN_vs_lg':
                    data.push({
                        x: results.valueOfN.map(val => 1 / val),
                        y: results.valueOfeg.map(val => val * 1000), // mm
                        mode: 'lines',
                        name: 'Air Gap vs. 1/N',
                        line: { color: 'black', dash: 'dash', width: 2 }
                    });
                    layout = {
                        title: 'Air Gap ($l_g$) vs. Inverse Number of Turns (1/N)',
                        xaxis: { title: '1/N' },
                        yaxis: { title: 'Air Gap ($l_g$) (mm)' }
                    };
                    plotDescription = 'This plot shows the relationship between the air gap and the inverse of the number of turns, often used to linearize certain design relationships.';
                    break;
                case 'A_vs_N':
                    data.push({
                        x: results.A.map(val => val * 1e6), // mm^2
                        y: results.valueOfN,
                        mode: 'lines',
                        name: 'N vs. Area',
                        line: { color: 'black', dash: 'dash', width: 3 }
                    });
                    layout = {
                        title: 'Number of Turns (N) vs. Core Cross-sectional Area (A)',
                        xaxis: { title: 'Core Cross-sectional Area (A) (mm²)' },
                        yaxis: { title: 'Number of Turns (N)' }
                    };
                    plotDescription = 'This plot shows how the number of turns varies with the core cross-sectional area. Larger core areas generally allow for fewer turns to achieve the desired inductance.';
                    break;
                case 'P_vs_Vc':
                    data.push({
                        x: results.P,
                        y: results.Vc,
                        mode: 'lines',
                        name: 'Total Loss vs. Core Volume',
                        line: { color: 'black', dash: 'dash', width: 3 }
                    });
                    if (Number.isFinite(results.closest_P) && Number.isFinite(results.closest_Vc)) {
                        data.push({
                            x: [results.closest_P],
                            y: [results.closest_Vc],
                            mode: 'markers',
                            name: 'Closest Point',
                            marker: { size: 10, color: 'blue', symbol: 'circle' }
                        });
                        // Add lines to show intersection point (requires P_norm and Vc_norm logic)
                        if (results.P_norm.length > 0 && results.Vc_norm.length > 0 && results.idx_maxVc !== -1 && results.idx_minVc !== -1) {
                            const P_at_maxVc = results.P[results.idx_maxVc];
                            const Vc_at_minVc = results.Vc[results.idx_minVc];
                            data.push({
                                x: [P_at_maxVc, P_at_maxVc],
                                y: [Math.min(...results.Vc), Math.max(...results.Vc)],
                                mode: 'lines',
                                name: 'Vertical from max Vc',
                                line: { color: 'blue', width: 2, dash: 'dot' }
                            });
                            data.push({
                                x: [Math.min(...results.P), Math.max(...results.P)],
                                y: [Vc_at_minVc, Vc_at_minVc],
                                mode: 'lines',
                                name: 'Horizontal from min Vc',
                                line: { color: 'blue', width: 2, dash: 'dot' }
                            });
                            data.push({
                                x: [P_at_maxVc, results.closest_P],
                                y: [Vc_at_minVc, results.closest_Vc],
                                mode: 'lines',
                                name: 'Distance to Closest',
                                line: { color: 'blue', width: 1.5, dash: 'dash' }
                            });
                        }
                    }
                    layout = {
                        title: 'Total Loss (P) vs. Core Volume ($V_c$)',
                        xaxis: { title: 'Total Loss (W)' },
                        yaxis: { title: 'Core Volume ($V_c$) (cm³)' },
                        showlegend: true
                    };
                    plotDescription = 'This plot shows the total power loss as a function of core volume. The "closest point" indicates a design compromise between minimizing loss and core volume, often found near the intersection of normalized loss and volume curves.';
                    break;
                case 'N_vs_Vc':
                    data.push({
                        x: results.valueOfN,
                        y: results.Vc,
                        mode: 'lines',
                        name: 'Turns vs. Core Volume',
                        line: { color: 'red', width: 2 }
                    });
                    if (Number.isFinite(results.closest_N) && Number.isFinite(results.closest_Vc)) {
                        data.push({
                            x: [results.closest_N],
                            y: [results.closest_Vc],
                            mode: 'markers',
                            name: 'Optimal Point',
                            marker: { size: 10, color: 'red', symbol: 'circle' }
                        });
                    }
                    layout = {
                        title: 'Number of Turns (N) vs. Core Volume ($V_c$) with Optimal Point',
                        xaxis: { title: 'Number of Turns (N)' },
                        yaxis: { title: 'Core Volume ($V_c$) (cm³)' },
                        showlegend: true
                    };
                    plotDescription = 'This plot visualizes the relationship between the number of turns and the core volume. The optimal point (marked in red) represents a balance for the design, often derived from the loss vs. volume analysis.';
                    break;
                case 'A_vs_L':
                    data.push({
                        x: results.A.map(val => val * 1e6), // mm^2
                        y: results.L1.map(val => val * 1e6), // uH
                        mode: 'lines',
                        name: 'Real Inductance',
                        line: { color: 'black', dash: 'dash', width: 3 }
                    });
                    data.push({
                        x: [Math.min(...results.A.map(val => val * 1e6)), Math.max(...results.A.map(val => val * 1e6))],
                        y: [results.L_target * 1e6, results.L_target * 1e6], // Target L in uH
                        mode: 'lines',
                        name: 'Target Inductance',
                        line: { color: 'blue', width: 3 }
                    });
                    layout = {
                        title: 'Inductance (L) vs. Core Cross-sectional Area (A)',
                        xaxis: { title: 'Core Cross-sectional Area (A) (mm²)' },
                        yaxis: { title: 'Inductance (L) (μH)' },
                        showlegend: true
                    };
                    plotDescription = 'This plot compares the calculated inductance with the target inductance as the core cross-sectional area varies. The blue line indicates the desired inductance value.';
                    break;
                case 'A_vs_B':
                    data.push({
                        x: results.A.map(val => val * 1e6), // mm^2
                        y: results.B1,
                        mode: 'lines',
                        name: 'Real Flux Density',
                        line: { color: 'black', dash: 'dash', width: 3 }
                    });
                    data.push({
                        x: [Math.min(...results.A.map(val => val * 1e6)), Math.max(...results.A.map(val => val * 1e6))],
                        y: [0.2, 0.2], // B_target from input
                        mode: 'lines',
                        name: 'Target Flux Density',
                        line: { color: 'blue', dash: 'dash', width: 3 }
                    });
                    layout = {
                        title: 'Magnetic Flux Density (B) vs. Core Cross-sectional Area (A)',
                        xaxis: { title: 'Core Cross-sectional Area (A) (mm²)' },
                        yaxis: { title: 'Magnetic Flux Density (B) (T)' },
                        showlegend: true
                    };
                    plotDescription = 'This plot shows the actual magnetic flux density in the core versus its cross-sectional area, compared against the target flux density used in the design.';
                    break;
                case 'Energy_vs_A':
                    data.push({
                        x: results.A.map(val => val * 1e6), // mm^2
                        y: results.Em,
                        mode: 'lines',
                        name: 'Magnetic Energy ($E_m$)',
                        line: { color: 'black', dash: 'dash', width: 3 }
                    });
                    data.push({
                        x: results.A.map(val => val * 1e6), // mm^2
                        y: results.Ee,
                        mode: 'lines',
                        name: 'Electrical Energy ($E_L$)',
                        line: { color: 'blue', dash: 'dash', width: 3 }
                    });
                    layout = {
                        title: 'Electromagnetic Energy vs. Core Cross-sectional Area (A)',
                        xaxis: { title: 'Core Cross-sectional Area (A) (mm²)' },
                        yaxis: { title: 'Electromagnetic Energy (μJ)' },
                        showlegend: true
                    };
                    plotDescription = 'This plot compares the magnetic energy stored in the core ($E_m$) and the electrical energy stored in the inductor ($E_L$) as the core area changes.';
                    break;
                case 'Loss_vs_N_A':
                    // Dual Y-axis plot
                    data.push({
                        x: results.valueOfN,
                        y: results.P,
                        mode: 'lines',
                        name: 'Loss vs. N',
                        line: { color: 'black', dash: 'dash', width: 3 },
                        yaxis: 'y1'
                    });
                    data.push({
                        x: results.A.map(val => val * 1e6), // mm^2
                        y: results.P,
                        mode: 'lines',
                        name: 'Loss vs. A',
                        line: { color: 'blue', dash: 'dash', width: 3 },
                        xaxis: 'x2',
                        yaxis: 'y1'
                    });
                    layout = {
                        title: 'Total Loss (P) vs. Number of Turns (N) and Core Area (A)',
                        xaxis: { title: 'Number of Turns (N)', domain: [0, 1] },
                        yaxis: { title: 'Loss (W)' },
                        xaxis2: { title: 'Core Area (A) (mm²)', overlaying: 'x', side: 'top' },
                        showlegend: true
                    };
                    plotDescription = 'This plot shows the total power loss as a function of both the number of turns and the core cross-sectional area, using a dual X-axis to visualize both relationships simultaneously.';
                    break;
                case 'Volume_vs_N_A':
                    // Dual Y-axis plot
                    data.push({
                        x: results.valueOfN,
                        y: results.Vc,
                        mode: 'lines',
                        name: 'Volume vs. N',
                        line: { color: 'black', dash: 'dash', width: 3 },
                        yaxis: 'y1'
                    });
                    data.push({
                        x: results.A.map(val => val * 1e6), // mm^2
                        y: results.Vc,
                        mode: 'lines',
                        name: 'Volume vs. A',
                        line: { color: 'blue', dash: 'dash', width: 3 },
                        xaxis: 'x2',
                        yaxis: 'y1'
                    });
                    layout = {
                        title: 'Core Volume ($V_c$) vs. Number of Turns (N) and Core Area (A)',
                        xaxis: { title: 'Number of Turns (N)', domain: [0, 1] },
                        yaxis: { title: 'Core Volume (cm³)' },
                        xaxis2: { title: 'Core Area (A) (mm²)', overlaying: 'x', side: 'top' },
                        showlegend: true
                    };
                    plotDescription = 'This plot shows the core volume as a function of both the number of turns and the core cross-sectional area, illustrating how these parameters influence the physical size of the magnetic component.';
                    break;
                case 'Aw_vs_N':
                    data.push({
                        x: results.valueOfN,
                        y: results.Aw.map(val => val * 1e6), // mm^2
                        mode: 'lines',
                        name: 'Window Area vs. N',
                        line: { color: 'magenta', width: 2 }
                    });
                    if (Number.isFinite(results.summary_at_N12.N_at_N12) && Number.isFinite(results.summary_at_N12.Aw_at_N12)) {
                        data.push({
                            x: [results.summary_at_N12.N_at_N12],
                            y: [results.summary_at_N12.Aw_at_N12],
                            mode: 'markers',
                            name: 'N=12 Point',
                            marker: { size: 10, color: 'black', symbol: 'circle' }
                        });
                    }
                    layout = {
                        title: 'Window Area ($A_w$) vs. Number of Turns (N)',
                        xaxis: { title: 'Number of Turns (N)' },
                        yaxis: { title: 'Window Area ($A_w$) (mm²)' },
                        showlegend: true
                    };
                    plotDescription = 'This plot shows the required window area for the windings as the number of turns varies. A larger window area is needed for more turns or thicker wire.';
                    break;
                case 'Dc_vs_N':
                    data.push({
                        x: results.valueOfN,
                        y: results.Dc.map(val => val * 1e3), // mm
                        mode: 'lines',
                        name: 'Core Diameter vs. N',
                        line: { color: 'green', width: 2 }
                    });
                    if (Number.isFinite(results.summary_at_N12.N_at_N12) && Number.isFinite(results.summary_at_N12.Dc_at_N12)) {
                        data.push({
                            x: [results.summary_at_N12.N_at_N12],
                            y: [results.summary_at_N12.Dc_at_N12],
                            mode: 'markers',
                            name: 'N=12 Point',
                            marker: { size: 10, color: 'black', symbol: 'circle' }
                        });
                    }
                    layout = {
                        title: 'Core Diameter ($D_c$) vs. Number of Turns (N)',
                        xaxis: { title: 'Number of Turns (N)' },
                        yaxis: { title: 'Core Diameter ($D_c$) (mm)' },
                        showlegend: true
                    };
                    plotDescription = 'This plot illustrates how the core diameter changes with the number of turns. This relationship is crucial for selecting an appropriate core size.';
                    break;
                case 'L_vs_lg':
                    data.push({
                        x: results.valueOfeg.map(val => val * 1e3), // mm
                        y: results.L1.map(val => val * 1e6), // uH
                        mode: 'lines',
                        name: 'Inductance vs. Air Gap',
                        line: { color: 'black', dash: 'dash', width: 3 }
                    });
                    // Highlight N=12 point if available
                    if (Number.isFinite(results.summary_at_N12.eg_at_N12) && Number.isFinite(results.summary_at_N12.L1_at_N12)) {
                        data.push({
                            x: [results.summary_at_N12.eg_at_N12],
                            y: [results.summary_at_N12.L1_at_N12],
                            mode: 'markers',
                            name: 'N=12 Point',
                            marker: { size: 10, color: 'red', symbol: 'circle' }
                        });
                    }
                    layout = {
                        title: 'Inductance (L) vs. Air Gap ($l_g$)',
                        xaxis: { title: 'Air Gap ($l_g$) (mm)', range: [0, 2] }, // Set xlim from MATLAB
                        yaxis: { title: 'Inductance (L) (μH)', range: [0, 20] }, // Set ylim from MATLAB
                        showlegend: true
                    };
                    plotDescription = 'This plot shows how the inductance changes with the air gap length. A larger air gap generally reduces inductance but can improve saturation characteristics.';
                    break;
                case 'L_vs_Dc':
                    data.push({
                        x: results.Dc.map(val => val * 1e3), // mm
                        y: results.L1.map(val => val * 1e6), // uH
                        mode: 'lines',
                        name: 'Inductance vs. Core Diameter',
                        line: { color: 'blue', width: 2 }
                    });
                    // Highlight N=12 point if available
                    if (Number.isFinite(results.summary_at_N12.Dc_at_N12) && Number.isFinite(results.summary_at_N12.L1_at_N12)) {
                        data.push({
                            x: [results.summary_at_N12.Dc_at_N12],
                            y: [results.summary_at_N12.L1_at_N12],
                            mode: 'markers',
                            name: 'N=12 Point',
                            marker: { size: 10, color: 'red', symbol: 'circle' }
                        });
                    }
                    layout = {
                        title: 'Inductance (L) vs. Core Diameter ($D_c$)',
                        xaxis: { title: 'Core Diameter ($D_c$) (mm)' },
                        yaxis: { title: 'Inductance (L) (μH)' },
                        showlegend: true
                    };
                    plotDescription = 'This plot illustrates the relationship between the inductance and the core diameter. Larger core diameters generally allow for higher inductance with fewer turns.';
                    break;
                default:
                    plotDiv.innerHTML = '<p class="text-gray-500">Select a plot type from the dropdown.</p>';
                    descriptionDiv.textContent = '';
                    return;
            }

            Plotly.newPlot(plotDiv, data, layout, { responsive: true });
            descriptionDiv.textContent = plotDescription;
        }

        // Event Listeners
        document.getElementById('calculateInductorButton').addEventListener('click', calculateInductorDesign);
        document.getElementById('inductorPlotType').addEventListener('change', () => {
            if (inductorResults) { // Only plot if calculations have been performed
                plotInductorResults(inductorResults, document.getElementById('inductorPlotType').value);
            }
        });

        // Initial calculation and plot on page load
        document.addEventListener('DOMContentLoaded', () => {
            calculateInd
