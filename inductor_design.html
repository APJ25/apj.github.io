<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Inductor Design Analysis</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
            color: #334155;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }
        .input-group {
            display: flex;
            flex-direction: column;
            margin-bottom: 1rem;
        }
        .input-group label {
            margin-bottom: 0.5rem;
            font-weight: 600;
        }
        .input-group input, .input-group select {
            padding: 0.75rem;
            border: 1px solid #cbd5e1;
            border-radius: 0.5rem;
            font-size: 1rem;
            background-color: #ffffff;
            transition: border-color 0.2s;
        }
        .input-group input:focus, .input-group select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.25);
        }
        .btn {
            padding: 0.75rem 1.5rem;
            background-color: #3b82f6;
            color: white;
            border-radius: 0.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            border: none;
        }
        .btn:hover {
            background-color: #2563eb;
            transform: translateY(-1px);
        }
        .btn:active {
            transform: translateY(0);
        }
        .plot-container {
            background-color: #ffffff;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
            margin-top: 2rem;
            min-height: 400px; /* Ensure plot div has height */
            display: flex;
            flex-direction: column; /* Allow content to stack */
            justify-content: center;
            align-items: center;
            position: relative; /* For loading indicator */
        }
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10;
            border-radius: 0.75rem;
        }
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #3b82f6;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 2rem;
            background-color: #ffffff;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            overflow: hidden; /* For rounded corners on table */
        }
        th, td {
            padding: 1rem;
            text-align: left;
            border-bottom: 1px solid #e2e8f0;
        }
        th {
            background-color: #f8fafc;
            font-weight: 600;
            color: #475569;
        }
        tr:last-child td {
            border-bottom: none;
        }
        tr:hover {
            background-color: #f0f4f8;
        }

        .explanation-section {
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid #e2e8f0;
        }
        .explanation-section:last-of-type {
            border-bottom: none;
        }
        .explanation-section h2 {
            font-size: 2rem;
            font-weight: 700;
            color: #1e293b;
            margin-bottom: 1rem;
            text-align: center;
        }
        .explanation-section h3 {
            font-size: 1.5rem;
            font-weight: 600;
            color: #334155;
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
        }
        .explanation-section p {
            margin-bottom: 1rem;
            line-height: 1.7;
        }
        .equation-block {
            background-color: #f8fafc;
            border-left: 4px solid #3b82f6;
            padding: 1.25rem;
            margin: 1.5rem 0;
            border-radius: 0.5rem;
            font-family: 'Fira Code', 'Cascadia Code', monospace;
            font-size: 1.05rem;
            overflow-x: auto;
        }
        .equation-block .katex-display {
            margin: 0 !important;
        }
        .plot-description {
            text-align: center;
            font-style: italic;
            font-size: 0.95rem;
            color: #64748b;
            margin-top: 0.5rem;
            margin-bottom: 1rem;
        }
        .back-button-container {
            display: flex;
            justify-content: center;
            margin-top: 3rem;
        }
        .back-to-portfolio-btn {
            background-color: #6c757d;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            color: white;
            text-decoration: none;
            font-weight: 600;
            transition: background-color 0.2s, transform 0.1s;
        }
        .back-to-portfolio-btn:hover {
            background-color: #5a6268;
            transform: translateY(-2px);
        }
        /* Specific style for Plotly graph div within plot-container */
        #plot-area {
            width: 100%;
            height: 100%;
            min-height: 350px; /* Ensure Plotly takes up space */
            flex-grow: 1; /* Allow it to grow */
        }
    </style>
</head>
<body class="p-4">
    <div class="container bg-white rounded-xl shadow-lg p-6 md:p-8">
        <h1 class="text-3xl font-bold text-center text-gray-800 mb-6">Inductor Design Analysis</h1>

        <div class="explanation-section">
            <h2>Introduction to Inductor Design</h2>
            <p>Inductors are crucial components in power electronic converters, used for energy storage, filtering, and current ripple reduction. Unlike transformers, inductors primarily store energy in their magnetic field. Their design involves carefully balancing inductance requirements, DC current handling, ripple current, and thermal considerations. This section outlines the principles and calculations for designing a power inductor, enabling you to select an appropriate core and winding configuration for your application.</p>
            <p>A well-designed inductor minimizes losses, avoids saturation under peak current conditions, and fits within the available physical space.</p>
        </div>

        <div class="explanation-section">
            <h2>Core Selection and Material Properties</h2>
            <p>For inductors, core material selection is critical, particularly concerning saturation flux density ($B_{sat}$), permeability ($\mu_r$), and core losses at the operating frequency and flux swing. Air gaps are often introduced in inductor cores to increase the effective magnetic path length, reduce the effective permeability, and thereby prevent saturation and store more energy without saturating the core prematurely. Common core types for inductors include E-cores, Toroids, and Pot cores, often made from ferrites or powdered iron materials.</p>
            <p>Key parameters for inductor core selection:</p>
            <ul>
                <li><strong>Effective Area ($A_e$)</strong>: The cross-sectional area through which the magnetic flux passes.</li>
                <li><strong>Effective Magnetic Path Length ($l_e$)</strong>: The average length of the magnetic flux path.</li>
                <li><strong>Window Area ($W_a$)</strong>: The area available for winding turns.</li>
                <li><strong>Mean Length Per Turn (MLT)</strong>: The average length of a single winding turn.</li>
                <li><strong>Gap Length ($l_g$)</strong>: The length of the air gap, crucial for controlling inductance and preventing saturation.</li>
            </ul>
        </div>

        <div class="explanation-section">
            <h2>Fundamental Design Equations</h2>
            <p>Inductor design relies on fundamental electromagnetic principles to relate inductance, number of turns, core properties, and current handling capabilities.</p>

            <h3>Inductance and Number of Turns:</h3>
            <p>The inductance ($L$) of a gapped core inductor is given by:</p>
            <div class="equation-block">
                $$
                L = \frac{N^2}{\Re} = \frac{N^2 \cdot \mu_0 \cdot \mu_e \cdot A_e}{l_e} \approx \frac{N^2 \cdot \mu_0 \cdot A_e}{l_e / \mu_r + l_g}
                $$
                Where: <br>
                $N$ is the number of turns.<br>
                $\Re$ is the reluctance of the magnetic circuit.<br>
                $\mu_0$ is the permeability of free space ($4\pi \times 10^{-7}$ H/m).<br>
                $\mu_e$ is the effective permeability of the gapped core.<br>
                $A_e$ is the effective cross-sectional area of the core.<br>
                $l_e$ is the effective magnetic path length.<br>
                $l_g$ is the air gap length.<br>
                $\mu_r$ is the relative permeability of the core material.
            </div>
            <p>From this, the number of turns can be derived:</p>
            <div class="equation-block">
                $$
                N = \sqrt{\frac{L \cdot (l_e / \mu_r + l_g)}{\mu_0 \cdot A_e}}
                $$
            </div>

            <h3>Area Product ($A_p$) Method:</h3>
            <p>The Area Product ($A_p$) is a useful metric for initial core selection. It combines the core's magnetic and winding capabilities:</p>
            <div class="equation-block">
                $$
                A_p = A_e \cdot W_a = \left( \frac{L \cdot I_{pk}^2}{B_{max} \cdot K_u \cdot J_{max}} \right)
                $$
                Where: <br>
                $I_{pk}$ is the peak current through the inductor.<br>
                $B_{max}$ is the maximum allowable flux density (usually $B_{sat}$ or less).<br>
                $K_u$ is the winding utilization factor (typically 0.2 to 0.4 for inductors).<br>
                $J_{max}$ is the maximum allowable current density in the winding wire.
            </div>

            <h3>Peak Flux Density:</h3>
            <p>The peak flux density in the core is crucial to avoid saturation:</p>
            <div class="equation-block">
                $$
                B_{pk} = \frac{L \cdot I_{pk}}{N \cdot A_e}
                $$
            </div>

            <h3>Core Loss (Inductor):</h3>
            <p>Core losses in inductors also follow the Steinmetz equation, but the flux density swing ($\Delta B$) is typically due to the ripple current ($\Delta I$).</p>
            <div class="equation-block">
                $$
                \Delta B = \frac{L \cdot \Delta I}{N \cdot A_e}
                $$
                $$
                P_{core} = k \cdot f^{\alpha} \cdot (\Delta B)^{\beta} \cdot V_e
                $$
            </div>

            <h3>Copper Loss (Inductor):</h3>
            <p>Similar to transformers, copper losses depend on the RMS current ($I_{rms}$) and the AC resistance of the winding ($R_{ac}$), which is affected by skin and proximity effects.</p>
            <div class="equation-block">
                $$
                P_{copper} = I_{rms}^2 \cdot R_{ac} = I_{rms}^2 \cdot F_R \cdot R_{dc}
                $$
            </div>

            <h3>Total Power Loss and Temperature Rise:</h3>
            <p>The total loss and temperature rise calculation mirrors that of the transformer, using the core's thermal resistance.</p>
            <div class="equation-block">
                $$
                P_{total\_loss} = P_{core} + P_{copper}
                $$
                $$
                \Delta T = P_{total\_loss} \cdot R_{th}
                $$
            </div>
        </div>
        
        <h2 class="text-2xl font-bold text-center text-gray-800 mb-4">Interactive Inductor Design Tool</h2>
        <p class="text-center text-gray-600 mb-6">Adjust the parameters below to design an inductor and view its characteristics.</p>

        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 mb-8">
            <div class="input-group">
                <label for="inductorFrequency">Operating Frequency (f) [Hz]:</label>
                <input type="number" id="inductorFrequency" value="100000" step="1000">
            </div>
            <div class="input-group">
                <label for="inductorCurrent">Current (I) [A]:</label>
                <input type="number" id="inductorCurrent" value="8" step="0.1">
            </div>
            <div class="input-group">
                <label for="inductorPermeability">Relative Permeability ($\mu_r$):</label>
                <input type="number" id="inductorPermeability" value="2000" step="100">
            </div>
            <div class="input-group">
                <label for="inductorTargetL">Target Inductance (L) [H]:</label>
                <input type="number" id="inductorTargetL" value="12.7e-6" step="1e-7">
            </div>
            <div class="input-group">
                <label for="inductorFluxDensity">Magnetic Flux Density (B) [T]:</label>
                <input type="number" id="inductorFluxDensity" value="0.2" step="0.01">
            </div>
            <div class="input-group">
                <label for="inductorWireResistivity">Wire Resistivity ($\rho$) [$\Omega \cdot m$]:</label>
                <input type="number" id="inductorWireResistivity" value="1.72e-8" step="1e-9">
            </div>
            <div class="input-group">
                <label for="inductorCoreDiameterCoarseStart">Core Diameter (Dc_start) [m]:</label>
                <input type="number" id="inductorCoreDiameterCoarseStart" value="4e-3" step="0.5e-3">
            </div>
            <div class="input-group">
                <label for="inductorCoreDiameterCoarseEnd">Core Diameter (Dc_end) [m]:</label>
                <input type="number" id="inductorCoreDiameterCoarseEnd" value="14e-3" step="0.5e-3">
            </div>
            <div class="input-group">
                <label for="inductorNumPoints">Number of Data Points (s):</label>
                <input type="number" id="inductorNumPoints" value="100" step="10">
            </div>
            <div class="input-group">
                <label for="inductorPlotType">Select Plot:</label>
                <select id="inductorPlotType" class="w-full">
                    <option value="N_vs_lg">Air Gap vs. Number of Turns ($l_g$ vs N)</option>
                    <option value="A_vs_lg">Air Gap vs. Core Cross-sectional Area ($l_g$ vs A)</option>
                    <option value="invN_vs_lg">Air Gap vs. Inverse Number of Turns ($l_g$ vs 1/N)</option>
                    <option value="A_vs_N">Number of Turns vs. Core Cross-sectional Area (N vs A)</option>
                    <option value="P_vs_Vc">Total Loss vs. Core Volume (P vs $V_c$) with Optimal Point</option>
                    <option value="N_vs_Vc">Turns vs. Core Volume (N vs $V_c$) with Optimal Point</option>
                    <option value="A_vs_L">Inductance vs. Core Cross-sectional Area (L vs A)</option>
                    <option value="A_vs_B">Magnetic Flux Density vs. Core Cross-sectional Area (B vs A)</option>
                    <option value="Energy_vs_A">Electromagnetic Energy ($E_m$, $E_L$) vs. Core Cross-sectional Area (A)</option>
                    <option value="Loss_vs_N_A">Total Loss vs. N and A</option>
                    <option value="Volume_vs_N_A">Core Volume vs. N and A</option>
                    <option value="Aw_vs_N">Window Area vs. Number of Turns ($A_w$ vs N)</option>
                    <option value="Dc_vs_N">Core Diameter vs. Number of Turns ($D_c$ vs N)</option>
                    <option value="L_vs_lg">Inductance vs. Air Gap (L vs $l_g$)</option>
                    <option value="L_vs_Dc">Inductance vs. Core Diameter (L vs $D_c$)</option>
                </select>
            </div>
        </div>
        
        <div class="flex justify-center mb-8">
            <button id="calculateInductorButton" class="btn">Calculate and Plot Inductor</button>
        </div>

        <div id="inductorPlotContainer" class="plot-container">
            <div class="loading-overlay hidden" id="inductorLoadingOverlay">
                <div class="spinner"></div>
            </div>
            <div id="plot-area" style="min-height: 350px;"></div>
            <p id="inductorPlotDescription" class="plot-description"></p>
        </div>

        <div id="inductorDesignSummaryContainer" class="mt-8">
            <h2 class="text-2xl font-bold text-center text-gray-800 mb-4">Inductor Design Summary (at N=12 Turns)</h2>
            <div id="inductorDesignSummary" class="overflow-x-auto">
                <table class="min-w-full divide-y divide-gray-200">
                    <thead class="bg-gray-50">
                        <tr>
                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Parameter</th>
                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Value</th>
                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Unit</th>
                        </tr>
                    </thead>
                    <tbody class="bg-white divide-y divide-gray-200" id="inductorSummaryTableBody">
                        <tr><td>Air Gap ($l_g$)</td><td id="output_inductor_air_gap">N/A</td><td>mm</td></tr>
                        <tr><td>Number of Turns (N)</td><td id="output_inductor_num_turns">N/A</td><td></td></tr>
                        <tr><td>Core Cross-sectional Area (A)</td><td id="output_inductor_area">N/A</td><td>mm²</td></tr>
                        <tr><td>Window Area ($A_w$)</td><td id="output_inductor_aw">N/A</td><td>mm²</td></tr>
                        <tr><td>Core Diameter ($D_c$)</td><td id="output_inductor_dc">N/A</td><td>mm</td></tr>
                        <tr><td>Inductance ($L_1$)</td><td id="output_inductor_L1">N/A</td><td>μH</td></tr>
                        <tr><td>Core Volume ($V_c$)</td><td id="output_inductor_Vc">N/A</td><td>cm³</td></tr>
                        <tr><td>Core Loss ($P_{core}$)</td><td id="output_inductor_Pin">N/A</td><td>W</td></tr>
                        <tr><td>Copper Loss ($P_w$)</td><td id="output_inductor_Pw">N/A</td><td>W</td></tr>
                        <tr><td>Total Loss (P)</td><td id="output_inductor_P_total">N/A</td><td>W</td></tr>
                    </tbody>
                </table>
                <p class="text-center text-sm text-gray-600 mt-4"><em>Note: The core is R22/6/6 with an air gap of 0.867mm (as per original MATLAB comment, though calculated value may vary).</em></p>
            </div>
        </div>

        <div class="back-button-container">
            <a href="master_thesis_details.html" class="back-to-portfolio-btn">← Back to Thesis Details</a>
        </div>
    </div>

    <script>
        // Constants from MATLAB code
        const uo = 4 * Math.PI * 1e-7; // Permeability of free space
        // lc = 0e-3; // Core length (from MATLAB, seems to be 0) - This seems unusual for an inductor.
        // Assuming lc might be an effective path length or a general length for some calculations.
        // For actual core dimensions, it's better to use l_e and A_e from core datasheets.
        // For simplicity and to complete the code based on the provided equations,
        // I will derive l_e and lm from Dc, which is an approximation for an R-core (toroid/pot core).
        // For an R-core (or a pot core like R22/6/6 implied in the summary),
        // l_e is often derived from the core's geometry, as is A_e.
        // Here, we are using Dc to estimate A_e, and will assume simple relations for l_e and ml_t
        // to make the calculations work, as specific core geometry isn't given.

        // Steinmetz parameters (from MATLAB)
        const a1 = -0.1108;
        const b1 = 0.2134;
        const c1 = 4.213;
        const a2 = 0.215;
        const b2 = 0.1373;
        const c2 = 0.03359;
        const a3 = 1.022e+06;
        const b3 = -1.348;
        const c3 = -0.02106;

        let inductorResults = null; // To store calculated results for plotting

        // Helper function to filter out NaN values for plotting
        function filterNaN(arr) {
            return arr.filter(value => !isNaN(value) && Number.isFinite(value));
        }

        // Function to perform inductor design calculations
        function calculateInductorDesign() {
            // Show loading overlay
            document.getElementById('inductorLoadingOverlay').classList.remove('hidden');
            // Clear previous plot and description area
            document.getElementById('plot-area').innerHTML = ''; 
            document.getElementById('inductorPlotDescription').textContent = '';

            // Read input values
            const f = parseFloat(document.getElementById('inductorFrequency').value);
            const I = parseFloat(document.getElementById('inductorCurrent').value); // Average/DC current
            const ur = parseFloat(document.getElementById('inductorPermeability').value);
            const L_target = parseFloat(document.getElementById('inductorTargetL').value);
            const B_target = parseFloat(document.getElementById('inductorFluxDensity').value); // Peak flux density target
            const rau = parseFloat(document.getElementById('inductorWireResistivity').value); // Wire resistivity
            const Dc_coarse_start = parseFloat(document.getElementById('inductorCoreDiameterCoarseStart').value);
            const Dc_coarse_end = parseFloat(document.getElementById('inductorCoreDiameterCoarseEnd').value);
            const s = parseInt(document.getElementById('inductorNumPoints').value);

            // Assume a ripple current percentage for core loss calculation (e.g., 20% of DC current)
            const delta_I = I * 0.2; // Example: 20% ripple current peak-to-peak
            const I_rms = Math.sqrt(I**2 + (delta_I/ (2 * Math.sqrt(3)))**2); // RMS current approximation for triangular ripple

            // Steinmetz coefficients based on frequency
            // These formulas look like they are used for calculating alpha, Beta, k based on frequency,
            // which are then used in the Steinmetz equation P_core = k * f^alpha * (delta_B)^Beta * V_e
            const alpha = (a2 * Math.pow(f / 1000, b2) + c2); // f is in Hz, MATLAB uses kHz or similar for these coeffs?
            const Beta = (a1 * Math.pow(f / 1000, b1) + c1); // Adjusting f to kHz if coeffs are for kHz
            const k = a3 * Math.pow(f / 1000, b3) + c3; // If this assumption is wrong, remove /1000

            // Generate Dc values (linear interpolation)
            const Dc = [];
            for (let i = 0; i < s; i++) {
                const ratio = i / (s - 1);
                Dc.push(Dc_coarse_start + ratio * (Dc_coarse_end - Dc_coarse_start));
            }

            // Preallocate arrays
            const valueOfeg = new Array(s); // Air Gap (lg)
            const valueOfN = new Array(s); // Number of Turns (N)
            const A = new Array(s);       // Core Cross-sectional Area (Ae)
            const L1 = new Array(s);      // Calculated Inductance
            const Ee = new Array(s);      // Electric Energy (not directly calculated here, seems misnamed from Em)
            const B1 = new Array(s);      // Peak Flux Density
            const Em = new Array(s);      // Magnetic Energy Stored
            const Vc = new Array(s);      // Core Volume
            const Bac = new Array(s);     // AC Flux Density Swing (delta B)
            const Pin = new Array(s);     // Core Loss (P_core)
            const Pw = new Array(s);      // Copper Loss (P_copper)
            const P = new Array(s);       // Total Loss
            const Aw = new Array(s);      // Window Area
            const Le = new Array(s);      // Effective Magnetic Path Length (l_e)
            const lm = new Array(s);      // Mean Length per Turn (MLT)
            const DCR = new Array(s);     // DC Resistance of winding
            const Ap = new Array(s);      // Area Product (Ap)

            // Assume Ku and Jmax for Area Product calculation
            const Ku = 0.3; // Winding utilization factor
            const Jmax = 4e6; // A/m^2 (e.g., 4 A/mm^2) - Max current density

            // Thermal resistance (example value)
            const Rth = 30; // K/W or °C/W, typical for smaller cores, check datasheet

            // From the MATLAB comments, Sp = I / 4.5 * 1e-6 appears to be related to wire cross-sectional area
            // However, a direct wire area for a current I needs Jmax.
            // Let's assume Sp is target wire area, maybe I_rms / J_max for a single wire.
            // A more common approach is to calculate the required wire area and then find the number of strands.
            // Let's assume Sp is the Area_conductor for one turn for now (meters^2)
            const Area_conductor = I_rms / Jmax; // Single conductor area based on Jmax
            
            for (let i = 0; i < s; i++) {
                // Step 1: Calculate core area (Ae) - Assuming it's based on Dc
                A[i] = Math.PI * (Dc[i] / 2)**2; // Circular core cross-section (like a cylinder's face)
                                                 // If Dc is outer diameter of a toroid, Ae is different.
                                                 // For an E-core or pot core, A[i] = Ae (effective area)
                                                 // Let's assume Dc refers to the diameter of the central leg for simplicity
                                                 // or average diameter for a toroidal section, leading to this Ae.

                // Step 2: Estimate effective magnetic path length (le) and mean length per turn (lm)
                // These are highly core-geometry dependent. For approximation, relate to Dc.
                // For a pot core or E-core, l_e is typically given in datasheet.
                // As we're using Dc as a single varying parameter, we'll make a simplifying assumption.
                // Let's assume l_e is roughly 3-5 times Dc, and lm is around Pi * Dc for a simple winding.
                Le[i] = 3 * Dc[i]; // Approximation for effective magnetic path length
                lm[i] = Math.PI * Dc[i]; // Approximation for mean length per turn (circumference of core)

                // Inductance formula: L = N^2 * mu_0 * Ae / (le/ur + lg)
                // We need to solve for N and lg.
                // Let's iterate on lg to find corresponding N.
                // For the "interactive tool" we'll calculate N and lg given L_target and B_target.
                // This means we need to relate B_target to N, L, I, Ae.
                // B_target = (L_target * I) / (N * A[i]) => N = (L_target * I) / (B_target * A[i])
                // Then, from L = N^2 * mu_0 * Ae / (le/ur + lg), solve for lg:
                // (le/ur + lg) = N^2 * mu_0 * Ae / L
                // lg = (N^2 * mu_0 * Ae / L) - (le/ur)

                // Ensure B_target is not zero to avoid division by zero
                if (A[i] === 0 || B_target === 0 || L_target === 0 || I === 0) {
                    valueOfN[i] = NaN;
                    valueOfeg[i] = NaN;
                } else {
                    valueOfN[i] = (L_target * I) / (B_target * A[i]); // Calculate N based on target B and L
                    // Ensure N is a positive real number before using it
                    if (valueOfN[i] <= 0 || !Number.isFinite(valueOfN[i])) {
                        valueOfN[i] = NaN; // Invalidate N if it's not physical
                        valueOfeg[i] = NaN; // And corresponding eg
                    } else {
                        // Calculate air gap (lg) based on target L and calculated N
                        // Make sure the term inside sqrt for N is positive for the full formula
                        const term_for_lg = (valueOfN[i]**2 * uo * A[i]) / L_target;
                        if (term_for_lg > (Le[i] / ur)) { // Ensure lg is positive
                            valueOfeg[i] = term_for_lg - (Le[i] / ur);
                        } else {
                            valueOfeg[i] = NaN; // Invalid air gap
                        }
                    }
                }

                // Initial robust check for NaN/Infinity/negative values immediately after N and eg
                if (!Number.isFinite(valueOfN[i]) || !Number.isFinite(valueOfeg[i]) || valueOfN[i] < 0 || valueOfeg[i] < 0) {
                    valueOfN[i] = NaN; valueOfeg[i] = NaN; A[i] = NaN; L1[i] = NaN;
                    Ee[i] = NaN; B1[i] = NaN; Em[i] = NaN; Vc[i] = NaN;
                    Bac[i] = NaN; Pin[i] = NaN; Pw[i] = NaN; P[i] = NaN;
                    Aw[i] = NaN; Le[i] = NaN; lm[i] = NaN; DCR[i] = NaN; Ap[i] = NaN;
                    continue; // Skip remaining calculations for this iteration
                }

                // Core Volume (Vc) - Approximation based on Dc. For a pot core: pi * (r_outer^2 - r_inner^2) * height
                // Or simplified as A_e * l_e
                Vc[i] = A[i] * Le[i]; // m^3

                // Window Area (Aw) - Simplification: assume it scales with core diameter, or derived from core family.
                // Assuming a typical relationship for pot/E-cores: Aw = k * Dc^2. Or relate to Ae for approximation.
                // From the MATLAB comment `Aw[i] = valueOfN[i] * Sp / 0.78;` where Sp = I / 4.5 * 1e-6 (wire area for one turn)
                // This seems like Aw needed to accommodate N turns of wire with Area_conductor, and packing factor.
                const packing_factor = 0.4; // Typical packing factor for round wire (Ku in Ap equation)
                Aw[i] = (valueOfN[i] * Area_conductor) / packing_factor; // Area_conductor is Area_wire

                // Calculated Inductance (L1) - Recalculate using derived N and lg to ensure consistency
                // L = N^2 * mu_0 * Ae / (le/ur + lg)
                if ((Le[i] / ur + valueOfeg[i]) === 0) {
                    L1[i] = NaN;
                } else {
                    L1[i] = (valueOfN[i]**2 * uo * A[i]) / (Le[i] / ur + valueOfeg[i]);
                }

                // Peak Flux Density (B1)
                B1[i] = (L_target * I) / (valueOfN[i] * A[i]);

                // Magnetic Energy Stored (Em) = 0.5 * L * I^2
                Em[i] = 0.5 * L1[i] * I**2; // Or use L_target

                // Electric Energy (Ee) - this variable name seems to be a placeholder or misnomer.
                // In magnetic circuits, E_e typically refers to electric field energy.
                // If it's another form of magnetic energy, it should align.
                // Assuming this was meant to be another energy calculation, e.g., the energy due to the B field:
                Ee[i] = (B1[i]**2 / (2 * uo)) * Vc[i]; // Energy density * volume, but B1 is peak, so not exactly stored.
                                                       // Will set it as NaN for now or adjust if clarification provided.
                Ee[i] = NaN; // Setting to NaN as its meaning isn't clear in context of other energy.

                // AC Flux Density Swing (Bac) = (L * delta_I) / (N * Ae)
                if (valueOfN[i] * A[i] === 0) {
                    Bac[i] = NaN;
                } else {
                    Bac[i] = (L_target * delta_I) / (valueOfN[i] * A[i]);
                }

                // Core Loss (Pin) using Steinmetz equation
                // P_core = k * f^alpha * (delta_B)^Beta * V_e
                if (!Number.isFinite(Bac[i]) || Bac[i] < 0 || Vc[i] <= 0) {
                    Pin[i] = NaN;
                } else {
                    Pin[i] = k * Math.pow(f, alpha) * Math.pow(Bac[i], Beta) * Vc[i];
                }

                // DC Resistance of Winding (DCR) = (rho * N * MLT) / Area_conductor
                if (Area_conductor === 0) {
                    DCR[i] = NaN;
                } else {
                    DCR[i] = (rau * valueOfN[i] * lm[i]) / Area_conductor;
                }

                // Copper Loss (Pw) = I_rms^2 * R_dc (ignoring skin/proximity effects for simplicity as F_R not defined)
                Pw[i] = I_rms**2 * DCR[i];

                // Total Loss (P)
                P[i] = Pin[i] + Pw[i];

                // Area Product (Ap) = Ae * Wa (using calculated Aw as Wa)
                Ap[i] = A[i] * Aw[i];
            }

            // Store results for plotting and summary
            inductorResults = {
                Dc: filterNaN(Dc),
                lg: filterNaN(valueOfeg),
                N: filterNaN(valueOfN),
                A: filterNaN(A),
                Aw: filterNaN(Aw),
                L1: filterNaN(L1),
                Vc: filterNaN(Vc),
                Pin: filterNaN(Pin),
                Pw: filterNaN(Pw),
                P: filterNaN(P),
                B1: filterNaN(B1),
                Em: filterNaN(Em),
                Ap: filterNaN(Ap)
            };

            // Find optimal point (e.g., minimum total loss)
            let minLoss = Infinity;
            let optimalIndex = -1;
            for (let i = 0; i < P.length; i++) {
                if (Number.isFinite(P[i]) && P[i] < minLoss) {
                    minLoss = P[i];
                    optimalIndex = i;
                }
            }

            // Display summary for a specific N, for example, the N closest to 12 turns (as mentioned in table)
            // Or find the N that yields the minimum loss, if optimalIndex is valid.
            // Let's use the optimal point for the summary if found, otherwise, pick a sensible N or the first valid one.
            let summaryIndex = -1;
            if (optimalIndex !== -1) {
                summaryIndex = optimalIndex;
            } else {
                // Find an index for N close to 12 if optimal not found
                let targetN = 12;
                let minDiffN = Infinity;
                for (let i = 0; i < valueOfN.length; i++) {
                    if (Number.isFinite(valueOfN[i])) {
                        const diff = Math.abs(valueOfN[i] - targetN);
                        if (diff < minDiffN) {
                            minDiffN = diff;
                            summaryIndex = i;
                        }
                    }
                }
            }

            if (summaryIndex !== -1) {
                updateSummaryTable({
                    air_gap: valueOfeg[summaryIndex] * 1e3, // m to mm
                    num_turns: Math.round(valueOfN[summaryIndex]),
                    area: A[summaryIndex] * 1e6, // m^2 to mm^2
                    aw: Aw[summaryIndex] * 1e6, // m^2 to mm^2
                    dc: Dc[summaryIndex] * 1e3, // m to mm
                    L1: L1[summaryIndex] * 1e6, // H to uH
                    Vc: Vc[summaryIndex] * 1e6, // m^3 to cm^3 (1e6 cm^3/m^3)
                    Pin: Pin[summaryIndex],
                    Pw: Pw[summaryIndex],
                    P_total: P[summaryIndex]
                });
            } else {
                // Clear summary if no valid data
                updateSummaryTable({
                    air_gap: 'N/A', num_turns: 'N/A', area: 'N/A', aw: 'N/A',
                    dc: 'N/A', L1: 'N/A', Vc: 'N/A', Pin: 'N/A', Pw: 'N/A', P_total: 'N/A'
                });
            }

            // Plot the data
            plotInductorData(document.getElementById('inductorPlotType').value, optimalIndex);

            // Hide loading overlay
            document.getElementById('inductorLoadingOverlay').classList.add('hidden');
        }

        function plotInductorData(plotType, optimalIndex) {
            const plotDiv = document.getElementById('plot-area');
            const descriptionDiv = document.getElementById('inductorPlotDescription');
            let data = [];
            let layout = {};
            let description = "";

            if (!inductorResults) {
                descriptionDiv.textContent = "No data to plot. Please run calculations first.";
                return;
            }

            // Filter out NaN values from all arrays for plotting
            const { Dc, lg, N, A, Aw, L1, Vc, Pin, Pw, P, B1, Em, Ap } = inductorResults;

            // Prepare data and layout based on plotType
            switch (plotType) {
                case 'N_vs_lg':
                    data.push({ x: lg.map(val => val * 1e3), y: N, mode: 'markers+lines', type: 'scatter', name: 'N vs. lg' });
                    layout = { title: 'Air Gap vs. Number of Turns', xaxis: { title: 'Air Gap ($l_g$) [mm]' }, yaxis: { title: 'Number of Turns (N)' } };
                    description = "This plot shows the relationship between the required air gap length and the number of turns to achieve the target inductance and flux density. As the air gap increases, the number of turns generally decreases for a constant inductance.";
                    break;
                case 'A_vs_lg':
                    data.push({ x: lg.map(val => val * 1e3), y: A.map(val => val * 1e6), mode: 'markers+lines', type: 'scatter', name: 'A vs. lg' });
                    layout = { title: 'Air Gap vs. Core Cross-sectional Area', xaxis: { title: 'Air Gap ($l_g$) [mm]' }, yaxis: { title: 'Core Cross-sectional Area (A) [mm²]' } };
                    description = "This plot illustrates how the required core cross-sectional area changes with the air gap for the given design parameters. A larger area generally means fewer turns are needed for a given flux density.";
                    break;
                case 'invN_vs_lg':
                    data.push({ x: lg.map(val => val * 1e3), y: N.map(val => 1 / val), mode: 'markers+lines', type: 'scatter', name: '1/N vs. lg' });
                    layout = { title: 'Air Gap vs. Inverse Number of Turns', xaxis: { title: 'Air Gap ($l_g$) [mm]' }, yaxis: { title: '1/Number of Turns (1/N)' } };
                    description = "This plot provides an alternative view of the relationship between air gap and the number of turns, often used in graphical design methods.";
                    break;
                case 'A_vs_N':
                    data.push({ x: N, y: A.map(val => val * 1e6), mode: 'markers+lines', type: 'scatter', name: 'A vs. N' });
                    layout = { title: 'Number of Turns vs. Core Cross-sectional Area', xaxis: { title: 'Number of Turns (N)' }, yaxis: { title: 'Core Cross-sectional Area (A) [mm²]' } };
                    description = "This plot shows the trade-off between the number of turns and the core's effective area. Fewer turns require a larger core area to maintain inductance and flux density, and vice-versa.";
                    break;
                case 'P_vs_Vc':
                    data.push({ x: Vc.map(val => val * 1e6), y: P, mode: 'markers+lines', type: 'scatter', name: 'Total Loss' });
                    if (optimalIndex !== -1 && Number.isFinite(Vc[optimalIndex]) && Number.isFinite(P[optimalIndex])) {
                        data.push({
                            x: [Vc[optimalIndex] * 1e6],
                            y: [P[optimalIndex]],
                            mode: 'markers',
                            marker: { size: 10, color: 'red', symbol: 'star' },
                            name: 'Optimal Point (Min Loss)'
                        });
                    }
                    layout = { title: 'Total Loss vs. Core Volume', xaxis: { title: 'Core Volume ($V_c$) [cm³]' }, yaxis: { title: 'Total Loss (P) [W]' } };
                    description = "This plot shows how the total power loss (core + copper) changes with the core volume. The optimal point indicates the design with the minimum total loss for the given parameters.";
                    break;
                case 'N_vs_Vc':
                    data.push({ x: Vc.map(val => val * 1e6), y: N, mode: 'markers+lines', type: 'scatter', name: 'Number of Turns' });
                    if (optimalIndex !== -1 && Number.isFinite(Vc[optimalIndex]) && Number.isFinite(N[optimalIndex])) {
                        data.push({
                            x: [Vc[optimalIndex] * 1e6],
                            y: [N[optimalIndex]],
                            mode: 'markers',
                            marker: { size: 10, color: 'red', symbol: 'star' },
                            name: 'Optimal Point (Min Loss)'
                        });
                    }
                    layout = { title: 'Turns vs. Core Volume', xaxis: { title: 'Core Volume ($V_c$) [cm³]' }, yaxis: { title: 'Number of Turns (N)' } };
                    description = "This plot shows the relationship between the number of turns and the core volume. The optimal point, corresponding to minimum total loss, is highlighted.";
                    break;
                case 'A_vs_L':
                    data.push({ x: A.map(val => val * 1e6), y: L1.map(val => val * 1e6), mode: 'markers+lines', type: 'scatter', name: 'Inductance vs. Area' });
                    layout = { title: 'Inductance vs. Core Cross-sectional Area', xaxis: { title: 'Core Cross-sectional Area (A) [mm²]' }, yaxis: { title: 'Inductance (L) [μH]' } };
                    description = "This plot demonstrates how the achievable inductance varies with the core's cross-sectional area, assuming other parameters are adjusted accordingly to maintain the target flux density.";
                    break;
                case 'A_vs_B':
                    data.push({ x: A.map(val => val * 1e6), y: B1, mode: 'markers+lines', type: 'scatter', name: 'Flux Density vs. Area' });
                    layout = { title: 'Magnetic Flux Density vs. Core Cross-sectional Area', xaxis: { title: 'Core Cross-sectional Area (A) [mm²]' }, yaxis: { title: 'Magnetic Flux Density (B) [T]' } };
                    description = "This plot shows the resulting magnetic flux density in the core as the core cross-sectional area changes, given a fixed target inductance and current. It's important to keep B below the core's saturation flux density.";
                    break;
                case 'Energy_vs_A':
                    data.push({ x: A.map(val => val * 1e6), y: Em, mode: 'markers+lines', type: 'scatter', name: 'Magnetic Energy ($E_m$)' });
                    layout = { title: 'Electromagnetic Energy vs. Core Cross-sectional Area', xaxis: { title: 'Core Cross-sectional Area (A) [mm²]' }, yaxis: { title: 'Energy [Joule]' } };
                    description = "This plot shows the magnetic energy stored in the inductor's core as a function of the core's cross-sectional area.";
                    break;
                case 'Loss_vs_N_A':
                    // This requires a 3D scatter plot. Plotly supports it.
                    data.push({
                        x: N,
                        y: A.map(val => val * 1e6),
                        z: P,
                        mode: 'markers',
                        type: 'scatter3d',
                        marker: {
                            size: 4,
                            opacity: 0.8,
                            color: P, // Color by loss
                            colorscale: 'Viridis',
                            colorbar: { title: 'Total Loss (W)' }
                        },
                        name: 'Total Loss'
                    });
                    layout = {
                        title: 'Total Loss vs. N and A',
                        scene: {
                            xaxis: { title: 'Number of Turns (N)' },
                            yaxis: { title: 'Core Area (A) [mm²]' },
                            zaxis: { title: 'Total Loss (P) [W]' }
                        }
                    };
                    description = "This 3D plot visualizes how the total power loss changes with both the number of turns and the core's cross-sectional area. It helps in understanding the complex interdependencies.";
                    break;
                case 'Volume_vs_N_A':
                     // This requires a 3D scatter plot.
                     data.push({
                        x: N,
                        y: A.map(val => val * 1e6),
                        z: Vc.map(val => val * 1e6),
                        mode: 'markers',
                        type: 'scatter3d',
                        marker: {
                            size: 4,
                            opacity: 0.8,
                            color: Vc.map(val => val * 1e6), // Color by volume
                            colorscale: 'Plasma',
                            colorbar: { title: 'Core Volume (cm³)' }
                        },
                        name: 'Core Volume'
                    });
                    layout = {
                        title: 'Core Volume vs. N and A',
                        scene: {
                            xaxis: { title: 'Number of Turns (N)' },
                            yaxis: { title: 'Core Area (A) [mm²]' },
                            zaxis: { title: 'Core Volume ($V_c$) [cm³]' }
                        }
                    };
                    description = "This 3D plot illustrates the core volume as a function of both the number of turns and the core's cross-sectional area. This helps in physical sizing considerations.";
                    break;
                case 'Aw_vs_N':
                    data.push({ x: N, y: Aw.map(val => val * 1e6), mode: 'markers+lines', type: 'scatter', name: 'Window Area vs. N' });
                    layout = { title: 'Window Area vs. Number of Turns', xaxis: { title: 'Number of Turns (N)' }, yaxis: { title: 'Window Area ($A_w$) [mm²]' } };
                    description = "This plot shows the minimum window area required to accommodate the winding for a given number of turns, considering the wire size and packing factor.";
                    break;
                case 'Dc_vs_N':
                    data.push({ x: N, y: Dc.map(val => val * 1e3), mode: 'markers+lines', type: 'scatter', name: 'Core Diameter vs. N' });
                    layout = { title: 'Core Diameter vs. Number of Turns', xaxis: { title: 'Number of Turns (N)' }, yaxis: { title: 'Core Diameter ($D_c$) [mm]' } };
                    description = "This plot shows the relationship between the core diameter and the number of turns required to meet the inductance and flux density targets. Smaller core diameters generally require more turns.";
                    break;
                case 'L_vs_lg':
                    data.push({ x: lg.map(val => val * 1e3), y: L1.map(val => val * 1e6), mode: 'markers+lines', type: 'scatter', name: 'Inductance vs. Air Gap' });
                    layout = { title: 'Inductance vs. Air Gap', xaxis: { title: 'Air Gap ($l_g$) [mm]' }, yaxis: { title: 'Inductance (L) [μH]' } };
                    description = "This plot illustrates how the inductance varies with the air gap length. A larger air gap reduces the effective permeability, thus reducing the inductance for a fixed number of turns.";
                    break;
                case 'L_vs_Dc':
                    data.push({ x: Dc.map(val => val * 1e3), y: L1.map(val => val * 1e6), mode: 'markers+lines', type: 'scatter', name: 'Inductance vs. Core Diameter' });
                    layout = { title: 'Inductance vs. Core Diameter', xaxis: { title: 'Core Diameter ($D_c$) [mm]' }, yaxis: { title: 'Inductance (L) [μH]' } };
                    description = "This plot shows the relationship between the inductance and the core diameter. Larger core diameters generally allow for higher inductance for a given number of turns.";
                    break;
                default:
                    descriptionDiv.textContent = "Please select a plot type.";
                    return;
            }

            Plotly.newPlot(plotDiv, data, layout);
            descriptionDiv.textContent = description;
        }

        function updateSummaryTable(data) {
            document.getElementById('output_inductor_air_gap').textContent = data.air_gap !== 'N/A' ? data.air_gap.toFixed(3) : 'N/A';
            document.getElementById('output_inductor_num_turns').textContent = data.num_turns !== 'N/A' ? data.num_turns : 'N/A';
            document.getElementById('output_inductor_area').textContent = data.area !== 'N/A' ? data.area.toFixed(2) : 'N/A';
            document.getElementById('output_inductor_aw').textContent = data.aw !== 'N/A' ? data.aw.toFixed(2) : 'N/A';
            document.getElementById('output_inductor_dc').textContent = data.dc !== 'N/A' ? data.dc.toFixed(2) : 'N/A';
            document.getElementById('output_inductor_L1').textContent = data.L1 !== 'N/A' ? data.L1.toFixed(2) : 'N/A';
            document.getElementById('output_inductor_Vc').textContent = data.Vc !== 'N/A' ? data.Vc.toFixed(3) : 'N/A';
            document.getElementById('output_inductor_Pin').textContent = data.Pin !== 'N/A' ? data.Pin.toFixed(3) : 'N/A';
            document.getElementById('output_inductor_Pw').textContent = data.Pw !== 'N/A' ? data.Pw.toFixed(3) : 'N/A';
            document.getElementById('output_inductor_P_total').textContent = data.P_total !== 'N/A' ? data.P_total.toFixed(3) : 'N/A';
        }

        // Event Listeners
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('calculateInductorButton').addEventListener('click', calculateInductorDesign);
            // Initial calculation on load for default values
            calculateInductorDesign();
        });

        // Re-plot when plot type changes
        document.getElementById('inductorPlotType').addEventListener('change', () => {
            if (inductorResults) { // Only plot if data exists
                let minLossIndex = -1;
                let minLoss = Infinity;
                if (inductorResults.P) {
                    for (let i = 0; i < inductorResults.P.length; i++) {
                        if (Number.isFinite(inductorResults.P[i]) && inductorResults.P[i] < minLoss) {
                            minLoss = inductorResults.P[i];
                            minLossIndex = i;
                        }
                    }
                }
                plotInductorData(document.getElementById('inductorPlotType').value, minLossIndex);
            } else {
                document.getElementById('inductorPlotDescription').textContent = "No data to plot. Please run calculations first.";
            }
        });

    </script>
</body>
</html>
